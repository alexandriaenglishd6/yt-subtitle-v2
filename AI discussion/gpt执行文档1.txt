下面是一份把**《实施计划与验收清单》+《工程规范》合并在一起**的“施工版”文档草案（你可以直接放到 `docs/v3.2-playbook-and-standards.md`）。内容以你最终版设计文档为准（Phase 顺序、DoD、CI 门禁、日志策略、字幕合并与断点续传关键点等）。

---

# YouTube 字幕工具 v3.2 施工规范与验收清单（合并版草案）

**适用范围**：v3.2 的四个主 Phase（i18n 壳子 → 字幕智能合并 → 断点续传 → 时间预估/章节）+ 后续翻译补齐与旧硬编码迁移。
**目标优先级**：高并发不退化、质量（准确度/可读性）明显提升、长时间运行稳定（可恢复）。

---

## 0. 规范用词（执行强度）

本文使用 MUST/SHOULD/MAY 表示要求等级（避免“看起来像建议，实际上很关键”的情况）。这些词的语义按 RFC 2119 标准解释。([RFC 编辑器][1])

---

## 1. 总体施工策略（不跑偏的护栏）

### 1.1 范围与非目标（必须贴在 PR 模板里）

* **MUST** 只做 YouTube（不接其他平台）。
* **MUST NOT** 做：API 成本监控、自动主题分章、两轮润色、按字符比例拆时间轴。
* **MUST** 每个 Phase 都遵守“新代码全部走 `t()`/`tn()`，不新增硬编码”。（你的 CI 门禁也会卡这个）

### 1.2 提交与回滚策略（建议）

* **SHOULD** 每个 Phase 拆成多个小 PR：

  1. “引入接口/壳子（不动业务）” → 2) “接入一条关键路径” → 3) “补测试与门禁”
* **MUST** 保持可回滚：任何 PR 合并后都能跑通最小流程（至少 1 个视频）。

---

## 2. 工程规范（Engineering Standards）

> 这部分是“纪律”，不是功能；目的是保证并发、稳定、可维护、可扩语言。

### 2.1 i18n 规范（UI + 日志 + 输出都一致）

**核心原则**

* **MUST** 所有用户可见文本（GUI/CLI、日志 INFO+、Markdown 固定标题/字段名）都必须经 `t()` 或 `tn()`。
* **MUST** `t()/tn()` 是 *core 层统一入口*，UI 只能薄封装调用 core（消除 core 依赖 ui）。 

**复数与未来 10+ 语言**

* **MUST** 提供 `tn()`（复数/数量相关）接口并固定签名，业务层不得自行拼接数量文本。
* **SHOULD** 未来迁移 gettext 时，只替换 provider，不改业务代码；Python 标准库 `gettext.ngettext` 就是为不同语言的复数规则设计（有些语言不止两种复数形式）。([Python documentation][2])

**占位符规范**

* **MUST** 使用命名占位符（如 `{video_id}`、`{seconds}`），禁止字符串拼接；翻译资源里必须保留同名占位符。

**门禁（必须阻断合并）**

* **MUST** CI 同时跑：

  * 翻译文件 key 一致性检查
  * 硬编码字符串检测（非 `t()` 调用的用户可见文本）

---

### 2.2 日志规范（可运维 + 可本地化）

* **MUST** DEBUG 永远英文；INFO+ 必须本地化走 `t()`。
* **MUST** 同时保留稳定的 `event_code`（英文不翻译）用于排障/统计；message 走本地化。
* **SHOULD** Phase1 只改入口（logger 改用 `core.i18n.t()`），深度拆分后置，避免一次重构太大。

---

### 2.3 断点续传与落盘规范（长跑稳定性底座）

**manifest（状态机）**

* **MUST** manifest 是“单一状态机”，状态转换必须受控（不允许随处写 JSON）。
* **MUST** 防并发竞争：manifest 写入必须保证“单写者”（文件锁或写入队列任选其一）。

**原子写入**

* **MUST** 所有关键输出/manifest 落盘用 `tmp → os.replace`，防止中途崩溃留下半截文件。
* `os.replace` 的语义是：目标存在则替换，成功时是原子操作（POSIX 要求），但跨文件系统可能失败，所以 tmp 必须放同一目录/同一盘。([Python documentation][3])

---

### 2.4 重试与资源控制规范（高并发不雪崩）

**重试**

* **MUST** 使用指数退避 + 抖动（jitter），避免高并发同步重试导致 retry storm。
* **MUST** 对 429 尊重 `Retry-After`。
* **SHOULD** 参考 AWS 的 backoff+jitter 模式（SDK/官方设计模式里广泛使用）。([AWS 文档][4])

**错误分类（必须一致）**

* **MUST** 按你设计文档的表执行：超时/429/5xx 可重试；非 429 的 4xx 不重试；无字幕/视频不存在标记 SKIPPED 等。

**资源控制**

* **MUST** 每个视频结束释放大对象、清理 `.tmp`、with 关闭文件句柄；AI 并发有独立线程池/限制。

---

## 3. 实施计划与验收清单（Implementation + DoD）

> 每个 Phase 都给：范围（Scope）→ 交付物（Deliverables）→ DoD（完成定义）→ 验收用例（Acceptance）。

### Phase 1：i18n 框架壳子（2–4 小时）

**Scope**

* core 增加统一入口：`t()/tn()/set_language()`；provider 抽象，先 JSON provider。
* logger 改入口：从 `ui.i18n_manager` 改为 `core.i18n.t()`（最小改动）。
* UI 的 i18n manager 变薄封装（只调用 core）。

**Deliverables**

* 新增目录结构（core/i18n/provider/json_provider/locales）。
* CI 门禁：key 一致性检查 + 硬编码检测。

**DoD（必须全部满足）**

* [ ] 默认英文可运行（fallback 正常），中文不回退、不丢 key
* [ ] 新日志符合：DEBUG 英文，INFO+ 本地化，event_code 稳定
* [ ] CI 两个检查在主分支能跑通并阻断失败

**验收用例**

* 语言切换：GUI/CLI 文案、INFO 日志、Markdown 固定字段跟随语言变化
* 刻意删掉某语言 key：应 fallback 到英文或 key（按你的策略），不能崩溃

---

### Phase 2：字幕智能合并（1–2 天）

**Scope**

* 翻译前先合并 cue 成自然句块；合并后翻译；输出默认用“块时间范围”。
* 合并规则：标点断句、时间间隔阈值、最大/最小长度阈值。

**DoD**

* [ ] 默认输出策略是“块时间范围”（不做字符比例拆分）
* [ ] 单元测试覆盖：句子切分、合并规则、块时间范围（见测试计划）
* [ ] 新增 UI/日志/Markdown 字符串全部走 `t()/tn()`

**验收用例**

* 选 3 类视频：说话快/停顿多、演讲类、对话类
* 对比 v3.1：同样视频翻译结果“句子完整度、代词/时态一致性”明显更好（主观也可，但要有样例输出存档）

---

### Phase 3：断点续传（1–2 天）

**Scope**

* JSON manifest：记录 video 级阶段状态 + chunk 级恢复（采纳最终结论）。
* 输出/manifest 原子写入：tmp → os.replace。

**DoD**

* [ ] kill 进程后可 `--resume` 继续跑（跳过 done，继续 pending）
* [ ] manifest 写入无竞争（单写者机制）
* [ ] chunk 级失败能从失败 chunk 恢复（集成测试门槛）

**验收用例**

* 断点恢复：处理一半强制 kill → resume
* chunk 恢复：模拟翻译中途失败 → 再次运行从失败 chunk 接着走
* 输出文件不出现半截（要么旧版，要么新版完整）

---

### Phase 4：时间预估 + YouTube 原生章节支持（半天）

**Scope**

* ETA：滑动平均 / 分阶段统计均可，至少给“剩余时间”估算。
* 章节：复用 YouTube chapters 输出 Markdown 结构（不做自动主题分章）。

**DoD**

* [ ] ETA 文案走 `t()`（秒/分/小时等单位本地化）
* [ ] 有 chapters 时输出成章节化 Markdown；无 chapters 保持原输出
* [ ] 不引入任何额外 AI 调用（保持轻量）

**验收用例**

* 10 视频任务：ETA 随着完成逐步稳定（可不精确，但不离谱）
* 章节视频：Markdown 章节标题与时间范围正确

---

### Phase 5/6：补充翻译文件 + 迁移旧硬编码（按需、可慢慢做）

**DoD**

* [ ] 每新增一种语言：必须通过 key 一致性检查；缺失 key 有可控 fallback
* [ ] 每次迁移硬编码：必须减少硬编码计数（CI 扫描指标可输出报告）

---

## 4. 测试与发布门槛（Release Gate）

以你最终测试计划为发布门槛：

* 单测覆盖 core/i18n、subtitle merger、manifest（含原子写入与 chunk 恢复）、retry。
* 集成测试至少跑：10 视频小规模、kill 恢复、chunk 恢复、100+ 长跑稳定性。
* CI 必须跑：key 一致性 + 硬编码检测。

---

## 5. Code Review Checklist（贴 PR 模板）

**i18n**

* [ ] 新增用户可见字符串是否全部走 `t()/tn()`
* [ ] 占位符是否为命名占位符，且各语言一致
* [ ] 是否新增了硬编码日志/Markdown 固定字段

**稳定性/并发**

* [ ] 是否引入共享状态写入？是否保证单写者（manifest）
* [ ] 关键落盘是否 tmp→replace（同目录）([Python documentation][3])
* [ ] 重试是否指数退避+jitter，429 是否尊重 Retry-After

---

# 你接下来怎么用它（建议）

1. 先把这份文档放进仓库 `docs/`，然后加一个 **PR 模板**：把第 5 节 checklist 贴进去。
2. Phase 1 做完就把 CI 两个门禁真正接到默认 pipeline（否则后续很容易又硬编码）。

如果你愿意，我可以按你仓库现有结构（你设计文档里的文件结构变更表） 再补一页“**落地到目录/文件的施工清单**”（比如 Phase1 具体动哪些文件、每个 PR 的最小改动边界），让执行更像“施工图纸”。
