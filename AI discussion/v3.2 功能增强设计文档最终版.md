# YouTube 字幕工具 v3.2 功能增强设计文档（最终版）

> **版本**: v2.0 (Final)  
> **日期**: 2025-12-19  
> **状态**: 已审计通过  
> **审计方**: Claude, GPT-5, Grok  
> **修订说明**: 综合三方审计意见，修正风险点，补充遗漏项

---

## 一、项目背景与目标

### 1.1 项目现状

YouTube 字幕工具 v3.1 已具备完整的批量处理能力：

- ✅ 分阶段流水线架构（检测 → 下载 → 翻译 → 摘要 → 输出）
- ✅ 多 AI 供应商支持（OpenAI, Anthropic, Gemini, DeepSeek 等）
- ✅ GUI + CLI 双界面
- ✅ 基础 i18n 支持（中文/英文，约 990 条翻译）
- ✅ 智能并发控制

### 1.2 核心目标（按优先级）

| 优先级 | 目标 | 说明 |
|--------|------|------|
| **P0** | 多线程高并发 | 保持现有并发能力，新功能不引入性能瓶颈 |
| **P0** | 准确度/可读性 | 解决字幕切分导致的翻译质量问题 |
| **P0** | 长时间运行稳定性 | 支持大规模批量处理，崩溃可恢复 |
| **P1** | 国际化扩展 | 为 10+ 语言打好架构基础 |

### 1.3 明确不做的事项

- ❌ API 成本监控（避免功能臃肿）
- ❌ 跨平台支持（只做 YouTube）
- ❌ 自动主题分章（复杂度高，易翻车）
- ❌ 两轮翻译润色（成本翻倍）
- ❌ 按字符比例拆分时间轴（风险高，见审计结论）

---

## 二、现有代码分析

### 2.1 i18n 现状

**现有架构**：

```
ui/
  i18n_manager.py      ← UI 层翻译管理，提供 t() 函数
  i18n/
    zh_CN.json         ← 中文翻译（~990 行）
    en_US.json         ← 英文翻译（~990 行）

core/
  logger.py            ← 包含日志翻译逻辑，依赖 ui.i18n_manager
```

**问题**（三方共识）：
1. Core 模块依赖 UI 模块（`core/logger.py` 调用 `ui.i18n_manager.t()`）
2. CLI 模式下 i18n 会 fallback，日志国际化不完整
3. 没有统一的翻译入口，新模块不知道该调用哪个
4. 缺少复数规则支持（未来 10+ 语言的隐患）

### 2.2 需要重构的文件（基于 IDE 分析）

| 文件 | 行数 | 问题 | 重构时机 |
|------|------|------|----------|
| `core/logger.py` | 1013 | 职责混杂：日志 + 脱敏 + i18n + 轮转 | Phase 1 仅改入口，后续再拆 |
| `core/downloader.py` | 905 | `lang_matches()` 重复定义 | Phase 2 前提取 |
| `core/translator.py` | 771 | `lang_matches()` 重复定义 | Phase 2 前提取 |
| `core/pipeline/single_video.py` | 410 | 单函数 376 行，5 个阶段混在一起 | Phase 3 拆分 |

---

## 三、实施计划

### 3.1 总体路线图

```
Phase 1: i18n 架构统一 ──────────────────────────► [4-6 小时]
    │
    ├── 1.1 新建 core/i18n/（统一入口 + provider 抽象）
    ├── 1.2 修改 logger 调用新入口（不拆分文件）
    └── 1.3 UI 层改为薄封装
    
Phase 2: 公共模块提取 + 字幕智能合并 ─────────────► [1-2 天]
    │
    ├── 2.1 提取 lang_matches() → core/language_utils.py
    ├── 2.2 新建 core/subtitle/merger.py
    └── 2.3 实现句子合并 + 块级时间范围输出
    
Phase 3: 断点续传 ─────────────────────────────────► [1.5-2 天]
    │
    ├── 3.1 拆分 single_video.py 为阶段函数
    ├── 3.2 新建 core/state/manifest.py（单一状态机）
    ├── 3.3 实现 chunk 级恢复
    └── 3.4 实现原子写入
    
Phase 4: 时间预估 + 章节支持（可选）────────────────► [0.5 天]
    │
    ├── 4.1 ETA 计算逻辑
    └── 4.2 YouTube 原生章节提取（若存在则输出）
    
Phase 5: 翻译文件补充 + 旧代码迁移 ─────────────────► [按需]
```

### 3.2 详细时间表

| 阶段 | 任务 | 预估时间 | 交付物 |
|------|------|----------|--------|
| **Phase 1** | i18n 架构统一 | 4-6 小时 | `core/i18n/`（含 provider 抽象） |
| **Phase 2** | 字幕智能合并 | 1-2 天 | `core/language_utils.py`, `core/subtitle/merger.py` |
| **Phase 3** | 断点续传 | 1.5-2 天 | `core/state/manifest.py`, 重构后的 `single_video.py` |
| **Phase 4** | 时间预估 + 章节 | 0.5 天 | `core/pipeline/progress.py` |
| **Phase 5** | 迁移旧代码 | 按需 | 更新后的各模块 |
| **总计** | | **4-6 天** | |

---

## 四、Phase 1：i18n 架构统一

### 4.1 目标

1. 建立统一的 `t()` / `tn()` 翻译入口
2. 解除 Core 对 UI 的依赖
3. CLI 模式完整支持 i18n
4. 为 10+ 语言扩展打基础（含复数规则）
5. 预留 gettext 迁移路径

### 4.2 架构设计

**目标结构**：

```
core/
  i18n/
    __init__.py        ← 导出 t(), tn(), set_language()
    provider.py        ← Provider 抽象（短期 JSON，未来可切 gettext）
    json_provider.py   ← JSON 翻译文件加载器
    locales/
      zh_CN.json
      en_US.json
      ja_JP.json       ← 未来扩展

ui/
  i18n_manager.py      ← 改为调用 core.i18n（薄封装）
```

### 4.3 核心接口设计

```python
# core/i18n/__init__.py

from typing import Optional, Any, Protocol

class I18nProvider(Protocol):
    """翻译提供者协议（为未来 gettext 预留）"""
    def get(self, key: str, default: Optional[str] = None) -> str: ...
    def nget(self, singular: str, plural: str, n: int) -> str: ...

_provider: I18nProvider = None
_current_language: str = "en_US"

def set_language(lang_code: str) -> bool:
    """切换语言
    
    Args:
        lang_code: 语言代码（如 "zh_CN", "en_US", "ja_JP"）
    
    Returns:
        是否切换成功
    """
    global _provider, _current_language
    _current_language = lang_code
    # 加载对应语言的 provider
    ...

def t(key: str, default: Optional[str] = None, **kwargs) -> str:
    """翻译函数（主入口）
    
    Args:
        key: 翻译键，支持点号分隔（如 "log.download_started"）
        default: 未找到翻译时的默认值，若为 None 则返回 key
        **kwargs: 格式化参数（使用命名占位符）
    
    Returns:
        翻译后的字符串
    
    Examples:
        >>> t("download.started", video_id="abc123")
        "开始下载: abc123"  # 中文环境
        "Download started: abc123"  # 英文环境
    """
    if _provider is None:
        return _format_safe(default or key, **kwargs)
    
    text = _provider.get(key, default or key)
    return _format_safe(text, **kwargs)

def tn(singular: str, plural: str, n: int, **kwargs) -> str:
    """复数翻译函数
    
    为 10+ 语言准备，不同语言复数规则差异大：
    - 中文：无复数变化
    - 英文：1 个 vs 多个
    - 俄文：复杂的复数规则
    
    Args:
        singular: 单数形式的翻译键
        plural: 复数形式的翻译键
        n: 数量
        **kwargs: 格式化参数
    
    Examples:
        >>> tn("video.single", "video.plural", 5, count=5)
        "5 videos"  # 英文
        "5 个视频"  # 中文（无复数变化，singular 和 plural 可相同）
    """
    if _provider is None:
        key = singular if n == 1 else plural
        return _format_safe(key, n=n, **kwargs)
    
    text = _provider.nget(singular, plural, n)
    return _format_safe(text, n=n, **kwargs)

def _format_safe(text: str, **kwargs) -> str:
    """安全格式化，缺少参数时不崩溃"""
    try:
        return text.format(**kwargs)
    except KeyError:
        return text
```

### 4.4 Provider 抽象（为 gettext 预留）

```python
# core/i18n/json_provider.py

import json
from pathlib import Path
from typing import Optional

class JsonI18nProvider:
    """JSON 翻译文件加载器（短期方案）"""
    
    def __init__(self, locale_dir: Path, lang_code: str):
        self.translations = {}
        self._load(locale_dir, lang_code)
    
    def _load(self, locale_dir: Path, lang_code: str):
        # 先加载英文作为 fallback
        en_path = locale_dir / "en_US.json"
        if en_path.exists():
            self.translations = json.loads(en_path.read_text(encoding="utf-8"))
        
        # 再加载目标语言覆盖
        if lang_code != "en_US":
            target_path = locale_dir / f"{lang_code}.json"
            if target_path.exists():
                target_trans = json.loads(target_path.read_text(encoding="utf-8"))
                self.translations.update(target_trans)
    
    def get(self, key: str, default: Optional[str] = None) -> str:
        return self.translations.get(key, default or key)
    
    def nget(self, singular: str, plural: str, n: int) -> str:
        # JSON 简单实现：根据 n 选择 key
        # 未来可升级为 gettext 的复杂复数规则
        key = singular if n == 1 else plural
        return self.translations.get(key, key)
```

### 4.5 Logger 改造（最小改动）

**改造策略**（采纳 GPT 建议的渐进式）：
- Phase 1 只改入口，不拆分文件
- 脱敏逻辑拆分延后到功能稳定后

```python
# core/logger.py 改动点

# 改前
from ui import i18n_manager
def translate_log(key: str, **kwargs) -> str:
    i18n = _get_i18n()  # 延迟加载 ui.i18n_manager
    ...

# 改后
from core.i18n import t
def translate_log(key: str, **kwargs) -> str:
    return t(key, **kwargs)  # 直接调用统一入口
```

### 4.6 日志规范（新增，采纳 GPT 建议）

| 日志级别 | 语言策略 | 说明 |
|----------|----------|------|
| DEBUG | 英文 | 开发者排障用，保持稳定 |
| INFO+ | 本地化 | 用户可见，走 `t()` |
| event_code | 英文稳定 | 用于统计/排障，不翻译 |
| message | 本地化 | 用户可见文案 |

```python
# 推荐的日志写法
logger.info(t("log.download_started", video_id=vid))  # message 本地化
# 内部同时记录 event_code（用于排障）
self._emit_event("DOWNLOAD_STARTED", video_id=vid)  # event_code 稳定
```

---

## 五、Phase 2：字幕智能合并

### 5.1 问题分析

**当前问题**：YouTube 自动字幕按说话停顿切分，导致：
- 一句话被切成 3-4 段
- 翻译时上下文丢失
- 指代、时态不一致

### 5.2 合并策略

**核心原则**（三方共识）：
- 以可读性为一等公民
- 合并后翻译，而非翻译后拆分
- 输出块级时间范围，不强行拆回每个 cue

```
┌─────────────────────────────────────────────────────────────┐
│                     字幕处理流程                              │
├─────────────────────────────────────────────────────────────┤
│  原始 Cues ──► 句子合并 ──► AI 翻译 ──► 块时间范围输出        │
│     │              │            │            │               │
│  保留引用      按标点/间隔     翻译完整块    使用块的起止时间   │
└─────────────────────────────────────────────────────────────┘
```

**合并规则**（按优先级）：

| 规则 | 说明 | 阈值 |
|------|------|------|
| 标点断句 | 遇到 `。！？.!?` 断开 | - |
| 时间间隔 | 间隔 > 阈值视为新句 | 1.2 秒 |
| 最大长度 | 单块不超过上限 | 1000 字符 |
| 最小长度 | 合并后至少达到下限 | 20 字符 |

### 5.3 时间轴输出策略（重要修订）

**审计结论**：GPT 指出 Claude 原方案"按字符比例拆回 cue"风险高

**修订后方案**：

| 模式 | 说明 | 默认 |
|------|------|------|
| **块时间范围**（推荐） | 输出使用合并块的起止时间 | ✅ 默认 |
| 拆回 cue（可选） | 按句/词边界拆分，非字符比例 | ❌ 可选 |

```python
@dataclass  
class MergedBlock:
    """合并后的文本块"""
    text: str
    cues: List[SubtitleCue]  # 原始 cue 引用
    start_time: float        # 块起始时间（第一个 cue 的 start）
    end_time: float          # 块结束时间（最后一个 cue 的 end）

# 输出时直接使用块的时间范围
def format_translated_block(block: MergedBlock, translated_text: str) -> str:
    """格式化翻译后的块为 SRT 格式"""
    return f"""
{block.index}
{format_time(block.start_time)} --> {format_time(block.end_time)}
{translated_text}
"""
```

### 5.4 Overlap 策略

**目的**：提升长视频翻译的连贯性（指代、语气一致）

```
块 1: [句子1] [句子2] [句子3] [句子4]
块 2:                 [句子3] [句子4] [句子5] [句子6]  ← 重叠 2 句
```

**配置**：
- `overlap_sentences: int = 2`（默认重叠 2 句）
- 翻译后丢弃重叠部分，无缝拼接

---

## 六、Phase 3：断点续传

### 6.1 目标

1. 任务中断后可恢复
2. 单视频失败不影响整体
3. 支持 chunk 级恢复（长视频翻译）
4. 支持 `--resume` 和 `--force` 模式

### 6.2 状态模型（重要修订）

**审计结论**：GPT 指出 Claude 原方案"status + 多个 bool flags"容易状态矛盾

**修订后方案**：采用单一状态机

```python
# core/state/manifest.py

from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Optional
from datetime import datetime

class VideoStage(Enum):
    """视频处理阶段（单一状态机，无矛盾）"""
    PENDING = "pending"
    DETECTING = "detecting"
    DOWNLOADING = "downloading"
    TRANSLATING = "translating"
    SUMMARIZING = "summarizing"
    OUTPUTTING = "outputting"
    DONE = "done"
    FAILED = "failed"
    SKIPPED = "skipped"

@dataclass
class VideoState:
    """单个视频的处理状态"""
    video_id: str
    stage: VideoStage = VideoStage.PENDING
    
    # chunk 级恢复（用于翻译阶段）
    total_chunks: int = 0
    completed_chunks: List[int] = field(default_factory=list)
    failed_chunks: List[int] = field(default_factory=list)
    
    # 输出文件路径
    output_files: Dict[str, str] = field(default_factory=dict)
    
    # 错误信息
    error_message: Optional[str] = None
    error_code: Optional[str] = None  # 稳定的英文错误码
    retry_count: int = 0
    
    # 时间戳
    started_at: Optional[str] = None
    completed_at: Optional[str] = None

@dataclass
class TaskManifest:
    """任务清单"""
    # 元数据
    schema_version: str = "1.0"        # 用于兼容性检查
    task_id: str = ""                  # 格式：YYYYMMDD_HHMMSS
    source_url: str = ""
    config_hash: Optional[str] = None  # 配置快照哈希，恢复时验证
    
    # 统计
    total_videos: int = 0
    
    # 视频状态
    videos: Dict[str, VideoState] = field(default_factory=dict)
    
    # 时间戳
    created_at: str = ""
    updated_at: str = ""
```

### 6.3 Chunk 级恢复（新增，采纳 Grok 建议）

```python
def resume_translation(video_state: VideoState, chunks: List[str]) -> List[int]:
    """获取需要翻译的 chunk 索引列表"""
    all_indices = set(range(len(chunks)))
    completed = set(video_state.completed_chunks)
    failed = set(video_state.failed_chunks)
    
    # 跳过已完成的，重试失败的
    return sorted((all_indices - completed) | failed)
```

### 6.4 原子写入

```python
import os
from pathlib import Path
from tempfile import NamedTemporaryFile

def atomic_write_json(file_path: Path, data: dict) -> None:
    """原子写入 JSON 文件
    
    使用 tmp 文件 + os.replace 模式
    os.replace 在 POSIX 系统上是原子操作
    """
    file_path = Path(file_path)
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    with NamedTemporaryFile(
        mode='w',
        dir=file_path.parent,
        suffix='.tmp',
        delete=False,
        encoding='utf-8'
    ) as tmp:
        json.dump(data, tmp, ensure_ascii=False, indent=2)
        tmp_path = tmp.name
    
    os.replace(tmp_path, file_path)  # 原子替换
```

---

## 七、并发与稳定性设计（横切章节）

> **审计补充**：GPT 指出原文档缺少重试/退避策略，此为关键遗漏

### 7.1 重试策略（指数退避 + 抖动）

```python
import random
import time

def retry_with_backoff(
    func,
    max_retries: int = 3,
    base_delay: float = 1.0,
    max_delay: float = 60.0,
    jitter: float = 0.1,
):
    """带指数退避和抖动的重试
    
    避免高并发下所有线程同步重试导致"雪崩"
    
    Args:
        func: 要执行的函数
        max_retries: 最大重试次数
        base_delay: 基础延迟（秒）
        max_delay: 最大延迟（秒）
        jitter: 抖动比例（0-1）
    """
    for attempt in range(max_retries + 1):
        try:
            return func()
        except RetryableError as e:
            if attempt == max_retries:
                raise
            
            # 指数退避
            delay = min(base_delay * (2 ** attempt), max_delay)
            
            # 添加抖动（±jitter%）
            delay *= (1 + random.uniform(-jitter, jitter))
            
            logger.warning(t("log.retry_after_delay", 
                           attempt=attempt + 1, 
                           delay=delay, 
                           error=str(e)))
            time.sleep(delay)
```

### 7.2 可重试错误分类

| 错误类型 | 是否重试 | 说明 |
|----------|----------|------|
| 网络超时 | ✅ 是 | 指数退避重试 |
| HTTP 429 | ✅ 是 | 尊重 Retry-After 头 |
| HTTP 5xx | ✅ 是 | 服务端临时错误 |
| HTTP 4xx (非 429) | ❌ 否 | 客户端错误，重试无意义 |
| 视频不存在 | ❌ 否 | 标记 SKIPPED |
| 无字幕 | ❌ 否 | 标记 SKIPPED |
| API Key 无效 | ❌ 否 | 立即报错 |

### 7.3 资源控制

| 资源 | 控制策略 |
|------|----------|
| 内存 | 处理完单个视频后及时释放大对象 |
| 临时文件 | 每个视频完成后清理 .tmp 文件 |
| 文件句柄 | 使用 with 语句确保关闭 |
| API 并发 | 独立的 AI 并发线程池控制 |

---

## 八、Phase 4：时间预估 + 章节支持

### 8.1 ETA 计算

```python
@dataclass
class ProgressStats:
    """进度统计"""
    total: int
    completed: int
    failed: int
    
    # 耗时统计（滑动窗口平均）
    avg_seconds_per_video: float
    
    # ETA
    eta_seconds: float
    
    @property
    def eta_formatted(self) -> str:
        if self.eta_seconds < 60:
            return t("eta.seconds", seconds=int(self.eta_seconds))
        elif self.eta_seconds < 3600:
            return t("eta.minutes", minutes=int(self.eta_seconds / 60))
        else:
            hours = int(self.eta_seconds / 3600)
            minutes = int((self.eta_seconds % 3600) / 60)
            return t("eta.hours_minutes", hours=hours, minutes=minutes)
```

### 8.2 YouTube 章节支持（可选功能）

**范围澄清**：仅复用 yt-dlp 提取的原生章节，不做自动主题分章

```python
def extract_chapters(video_info: dict) -> List[Chapter]:
    """从 yt-dlp 返回的视频信息中提取章节
    
    仅当 YouTube 视频本身有章节时才返回
    不做任何自动推导
    """
    chapters = video_info.get('chapters', [])
    if not chapters:
        return []
    
    return [
        Chapter(
            title=ch.get('title', 'Untitled'),
            start_time=ch.get('start_time', 0),
            end_time=ch.get('end_time', 0)
        )
        for ch in chapters
    ]
```

---

## 九、文件结构变更总览

### 9.1 新增文件

```
core/
  i18n/
    __init__.py              ← 统一翻译入口 t(), tn(), set_language()
    provider.py              ← Provider 协议（抽象层）
    json_provider.py         ← JSON 加载器实现
    locales/
      zh_CN.json             ← 移动自 ui/i18n/
      en_US.json             ← 移动自 ui/i18n/
  
  subtitle/
    __init__.py
    merger.py                ← 字幕智能合并
  
  state/
    __init__.py
    manifest.py              ← 断点续传状态管理（单一状态机）
  
  language_utils.py          ← 提取的公共语言函数
  retry.py                   ← 重试策略（指数退避 + 抖动）
  
  pipeline/
    stages.py                ← 拆分后的处理阶段
    progress.py              ← 进度追踪
```

### 9.2 修改文件

| 文件 | 修改内容 |
|------|----------|
| `core/logger.py` | 改用 `core.i18n.t()` 作为翻译入口 |
| `core/downloader.py` | 删除重复的 `lang_matches()`，改用 `language_utils` |
| `core/translator.py` | 同上 |
| `core/pipeline/single_video.py` | 拆分为阶段函数 |
| `ui/i18n_manager.py` | 改为调用 `core.i18n`（薄封装） |

---

## 十、风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| i18n 重构破坏现有功能 | 高 | 保持 `t()` 接口兼容，逐步迁移 |
| 翻译文件 key 不同步 | 中 | 增加 CI 脚本检查所有语言文件 key 一致 |
| 并发写 manifest 竞争 | 中 | 使用文件锁或队列写入 |
| 字幕合并效果不佳 | 中 | 参数可配置，小规模测试验证 |
| 内存泄漏（长时间运行） | 中 | 定期检查，处理完及时释放 |
| yt-dlp 版本兼容 | 低 | 锁定版本，定期测试 |

---

## 十一、测试计划

### 11.1 单元测试

| 模块 | 测试重点 |
|------|----------|
| `core/i18n` | 翻译查找、fallback、格式化、复数、provider 切换 |
| `core/subtitle/merger` | 句子切分、合并规则、块时间范围 |
| `core/state/manifest` | 状态转换、原子写入、chunk 级恢复 |
| `core/retry` | 指数退避、抖动、重试次数 |

### 11.2 集成测试

1. **小规模测试**：10 个视频的频道，验证完整流程
2. **断点恢复测试**：中途 kill 进程，验证 `--resume` 功能
3. **chunk 恢复测试**：翻译中途失败，验证从失败 chunk 恢复
4. **长时间运行测试**：100+ 视频，验证稳定性和内存

### 11.3 CI 检查

- [ ] 翻译文件 key 一致性检查
- [ ] 硬编码字符串检测（非 `t()` 调用的用户可见文本）

---

## 十二、附录

### A. 三方 AI 审计共识

| 议题 | Claude | GPT | Grok | 最终采纳 |
|------|--------|-----|------|----------|
| i18n 放第几 | 第 1 | 第 1 | 第 1 | ✅ 第 1 |
| logger 改造深度 | 立即拆分 | 渐进式 | 渐进式 | **渐进式** |
| 时间轴映射 | 按字符比例拆 | 块时间范围 | 保留映射 | **块时间范围** |
| 断点恢复粒度 | 阶段级 | +chunk 级 | +chunk 级 | **chunk 级** |
| 复数支持 | `tn()` | `tn()` + gettext 路径 | 未提及 | **`tn()` + provider 抽象** |
| 重试策略 | 未详细 | 指数退避+抖动 | 未提及 | **指数退避+抖动** |

### B. gettext 迁移路径（未来可选）

当需要迁移到 gettext 时，只需：
1. 新建 `GettextI18nProvider` 实现 `I18nProvider` 协议
2. 在初始化时切换 provider
3. 业务代码无需改动（`t()` / `tn()` 接口不变）

### C. 参考资料

- Python gettext 官方文档：https://docs.python.org/3/library/gettext.html
- AWS 指数退避最佳实践：https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
- os.replace 原子性：https://docs.python.org/3/library/os.html#os.replace