"""
Cookie 管理器模块
支持 Cookie 测试和集成到 yt-dlp
"""
import tempfile
from pathlib import Path
from typing import Optional, Dict
import subprocess
import json

from core.logger import get_logger

logger = get_logger()


class CookieManager:
    """Cookie 管理器
    
    负责 Cookie 的测试和管理，支持将 Cookie 字符串转换为 yt-dlp 可用的格式
    """
    
    def __init__(self, cookie_string: str = "", yt_dlp_path: str = "yt-dlp"):
        """初始化 Cookie 管理器
        
        Args:
            cookie_string: Cookie 字符串（浏览器复制的格式）
            yt_dlp_path: yt-dlp 可执行文件路径
        """
        self.cookie_string = cookie_string.strip()
        self.yt_dlp_path = yt_dlp_path
        self._temp_cookie_file: Optional[Path] = None
    
    def _cookie_string_to_netscape_file(self, cookie_string: str) -> Optional[Path]:
        """将 Cookie 字符串转换为 Netscape 格式文件
        
        Args:
            cookie_string: Cookie 字符串（浏览器格式）
        
        Returns:
            临时文件路径，如果转换失败则返回 None
        """
        if not cookie_string:
            return None
        
        try:
            # 创建临时文件
            temp_file = tempfile.NamedTemporaryFile(
                mode='w',
                suffix='.txt',
                delete=False,
                encoding='utf-8'
            )
            temp_path = Path(temp_file.name)
            
            # 写入 Netscape Cookie 文件头
            temp_file.write("# Netscape HTTP Cookie File\n")
            temp_file.write("# This file was generated by yt-subtitle-v2\n\n")
            
            # 解析 Cookie 字符串（格式：key1=value1; key2=value2; ...）
            cookies = {}
            for item in cookie_string.split(';'):
                item = item.strip()
                if not item:
                    continue
                if '=' in item:
                    key, value = item.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    if key:  # 确保 key 不为空
                        cookies[key] = value
                else:
                    # 如果单个项目没有 '='，可能是格式错误，记录警告但继续
                    logger.warning(f"Cookie 格式可能不正确（缺少 '='）: {item[:50]}")
            
            # 检查是否解析到了 Cookie
            if not cookies:
                logger.error("Cookie 字符串解析后为空，无法创建 Cookie 文件")
                temp_file.close()
                temp_path.unlink()  # 删除空文件
                return None
            
            # 写入 Cookie（Netscape 格式）
            # Netscape 格式：domain, flag, path, secure, expiration, name, value
            # domain: 域名（.youtube.com 表示所有 youtube.com 子域）
            # flag: TRUE 表示所有主机都可以访问，FALSE 表示只有完全匹配的域名
            # path: Cookie 路径（/ 表示所有路径）
            # secure: TRUE 表示只在 HTTPS 连接中发送，FALSE 表示 HTTP 和 HTTPS 都可以
            # expiration: 过期时间（Unix 时间戳，0 表示会话 Cookie）
            # name: Cookie 名称
            # value: Cookie 值
            
            # 重要：YouTube 需要特定的 Cookie，特别是 __Secure-* 和 __Host-* 前缀的 Cookie
            # 这些 Cookie 需要正确的域名和 secure 标志
            for key, value in cookies.items():
                # 判断是否为安全 Cookie（__Secure- 或 __Host- 前缀）
                is_secure = key.startswith("__Secure-") or key.startswith("__Host-")
                
                # 对于安全 Cookie，使用 youtube.com 而不是 .youtube.com
                # 对于普通 Cookie，使用 .youtube.com
                if is_secure:
                    domain = "youtube.com"
                    secure_flag = "TRUE"
                else:
                    domain = ".youtube.com"
                    secure_flag = "TRUE"  # YouTube 现在主要使用 HTTPS
                
                # 写入 Netscape 格式：domain, flag, path, secure, expiration, name, value
                line = f"{domain}\tTRUE\t/\t{secure_flag}\t0\t{key}\t{value}\n"
                temp_file.write(line)
            
            logger.debug(f"已写入 {len(cookies)} 个 Cookie 到文件")
            
            temp_file.close()
            return temp_path
            
        except Exception as e:
            logger.error(f"转换 Cookie 字符串失败: {e}")
            return None
    
    def get_cookie_file_path(self) -> Optional[str]:
        """获取 Cookie 文件路径（用于 yt-dlp --cookies 参数）
        
        Returns:
            Cookie 文件路径，如果没有 Cookie 则返回 None
        """
        if not self.cookie_string:
            logger.debug("Cookie 字符串为空，返回 None")
            return None
        
        # 如果已经有临时文件，直接返回
        if self._temp_cookie_file and self._temp_cookie_file.exists():
            logger.debug(f"使用现有 Cookie 文件: {self._temp_cookie_file}")
            return str(self._temp_cookie_file)
        
        # 创建新的临时文件
        self._temp_cookie_file = self._cookie_string_to_netscape_file(self.cookie_string)
        if self._temp_cookie_file:
            logger.info(f"已创建 Cookie 文件: {self._temp_cookie_file}")
            return str(self._temp_cookie_file)
        else:
            logger.warning("创建 Cookie 文件失败")
            return None
    
    def test_cookie(self, test_url: str = "https://www.youtube.com") -> Dict[str, any]:
        """测试 Cookie 是否可用
        
        Args:
            test_url: 测试 URL，默认使用 YouTube 首页
        
        Returns:
            测试结果字典：
            {
                "available": bool,  # Cookie 是否可用
                "region": Optional[str],  # 所在地区（如果可检测）
                "error": Optional[str],  # 错误信息（如果有）
                "details": Dict  # 详细信息
            }
        """
        if not self.cookie_string:
            return {
                "available": False,
                "region": None,
                "error": "未配置 Cookie",
                "details": {}
            }
        
        logger.info("开始测试 Cookie...")
        
        try:
            # 获取 Cookie 文件路径
            cookie_file = self.get_cookie_file_path()
            if not cookie_file:
                return {
                    "available": False,
                    "region": None,
                    "error": "Cookie 文件创建失败",
                    "details": {}
                }
            
            # 使用 yt-dlp 测试 Cookie
            # 尝试获取一个简单的视频信息（使用一个公开的测试视频）
            test_video_url = "https://www.youtube.com/watch?v=jNQXAC9IVRw"  # 一个公开的测试视频
            
            cmd = [
                self.yt_dlp_path,
                "--dump-json",
                "--no-warnings",
                "--cookies", cookie_file,
                test_video_url
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode != 0:
                error_msg = result.stderr[:200] if result.stderr else "未知错误"
                logger.warning(f"Cookie 测试失败: {error_msg}")
                return {
                    "available": False,
                    "region": None,
                    "error": error_msg,
                    "details": {
                        "returncode": result.returncode,
                        "stderr": error_msg
                    }
                }
            
            # 解析 JSON 输出，尝试提取地区信息
            try:
                data = json.loads(result.stdout)
                region = None
                
                # 尝试从视频信息中提取地区信息
                # yt-dlp 可能在某些字段中包含地区信息
                if "geo_restricted" in data:
                    # 如果视频有地区限制，说明 Cookie 可能有效
                    pass
                
                # 尝试从其他字段推断地区（如果可用）
                # 注意：YouTube API 不直接返回用户地区，这里只是尝试
                
                logger.info("Cookie 测试成功：Cookie 可用")
                return {
                    "available": True,
                    "region": region,
                    "error": None,
                    "details": {
                        "video_id": data.get("id"),
                        "title": data.get("title", "")[:50],
                        "channel": data.get("channel", "")
                    }
                }
                
            except json.JSONDecodeError as e:
                logger.warning(f"解析测试结果失败: {e}")
                return {
                    "available": False,
                    "region": None,
                    "error": f"解析测试结果失败: {e}",
                    "details": {}
                }
                
        except subprocess.TimeoutExpired:
            logger.warning("Cookie 测试超时")
            return {
                "available": False,
                "region": None,
                "error": "测试超时",
                "details": {}
            }
        except Exception as e:
            logger.error(f"Cookie 测试时出错: {e}")
            import traceback
            logger.debug(traceback.format_exc())
            return {
                "available": False,
                "region": None,
                "error": str(e),
                "details": {}
            }
    
    def cleanup(self):
        """清理临时文件"""
        if self._temp_cookie_file and self._temp_cookie_file.exists():
            try:
                self._temp_cookie_file.unlink()
                self._temp_cookie_file = None
            except Exception as e:
                logger.warning(f"清理 Cookie 临时文件失败: {e}")
    
    def __del__(self):
        """析构函数，清理临时文件"""
        self.cleanup()

