# 高效开发工作流指南

> 本文档总结了零基础使用 AI 辅助开发的最佳实践，适用于非程序员高效完成复杂项目。

## 目录

1. [核心原则](#核心原则)
2. [工作流程](#工作流程)
3. [AI 协作模式](#ai-协作模式)
4. [检查清单](#检查清单)
5. [案例演示](#案例演示)
6. [常见陷阱](#常见陷阱)

---

## 核心原则

### 1️⃣ 规范先行，代码后写

| 错误做法 | 正确做法 |
|----------|----------|
| 想到什么写什么 | 先写规范文档 |
| 边做边改需求 | 需求确定后再开始 |
| 功能越多越好 | MVP 思维，只做必要的 |

### 2️⃣ 小步快跑，频繁测试

| 错误做法 | 正确做法 |
|----------|----------|
| 改完一堆才测试 | 每改 10 行就测试 |
| 问题堆积再处理 | 发现问题立即修复 |
| 等全部完成再验收 | 每个模块完成就验收 |

### 3️⃣ 单一真相来源

| 错误做法 | 正确做法 |
|----------|----------|
| 多个 AI 各自记忆 | 统一项目文档 |
| 口头约定需求 | 写入文档并确认 |
| 凭记忆修改 | 查阅文档后修改 |

### 4️⃣ 用户做选择，AI 做决定

| 错误做法 | 正确做法 |
|----------|----------|
| 外行指挥内行 | 提出需求，让 AI 设计 |
| 强行要求实现方式 | 说明目标，让 AI 选方案 |
| 忽视 AI 的警告 | 认真考虑 AI 的建议 |

---

## 工作流程

### 完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                      高效开发工作流                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ① 需求阶段                                                     │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  用户提出想法 → 写入项目文档 → AI 分析可行性               │   │
│  └──────────────────────────────────────────────────────────┘   │
│                          ↓                                       │
│  ② 设计阶段                                                     │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  主 AI 设计方案 → 对照检查清单 → 审核 AI Review            │   │
│  └──────────────────────────────────────────────────────────┘   │
│                          ↓                                       │
│  ③ 分歧处理（如有）                                             │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  AI 用通俗语言解释 → 用户做选择 → 记录到文档              │   │
│  └──────────────────────────────────────────────────────────┘   │
│                          ↓                                       │
│  ④ 执行阶段                                                     │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  IDE 执行 → 每步测试 → 发现问题立即修复                    │   │
│  └──────────────────────────────────────────────────────────┘   │
│                          ↓                                       │
│  ⑤ 验收阶段                                                     │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  功能测试 → 审核 AI Review → Git 提交 → 更新文档          │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 阶段详解

#### ① 需求阶段

**目标**：明确要做什么，不要怎么做

**步骤**：
1. 用自然语言描述你的想法
2. AI 帮你整理成结构化需求
3. 确认需求是否是 MVP 必须的
4. 写入项目文档

**案例**：
```
用户：我想让程序支持多个 API Key

AI 整理后的需求：
- 目标：支持多个 API Key 轮询，避免单 Key 限流
- 范围：翻译和摘要模块
- 优先级：P1
- 验收标准：配置 3 个 Key，程序自动轮询使用
```

#### ② 设计阶段

**目标**：确定怎么做

**步骤**：
1. 让主 AI 提出设计方案
2. 对照检查清单审核
3. 让审核 AI Review
4. 有疑问就提问，不要跳过

**案例**：
```
主 AI 设计方案：
- 创建 KeySelector 类管理多个 Key
- 使用轮询策略分配 Key
- 失败时自动切换下一个 Key

检查清单审核：
☑ 是否符合单一职责原则？是
☑ 是否有国际化遗漏？无
☑ 是否有硬编码？无
☑ 是否需要加锁？是，需要线程锁

审核 AI Review：
✅ 设计合理
⚠️ 建议：失败次数应该记录，连续失败的 Key 需要暂时禁用
```

#### ③ 分歧处理

**目标**：遇到技术分歧时做出选择

**步骤**：
1. AI 用通俗语言解释两种方案
2. 说明各自优缺点
3. 用户做出选择
4. 记录选择理由到文档

**案例**：
```
分歧：Key 失效后是立即切换还是等待恢复？

方案 A - 立即切换：
- 优点：不影响当前任务
- 缺点：可能浪费好 Key

方案 B - 等待恢复：
- 优点：节省 Key
- 缺点：延长任务时间

用户选择：方案 A
理由：用户体验优先，Key 多不怕浪费
```

#### ④ 执行阶段

**目标**：写代码并确保正确

**步骤**：
1. 让 IDE 执行设计方案
2. 每改 10 行就运行测试
3. 发现问题立即修复
4. 不要跳过测试

**案例**：
```
执行步骤：
1. 创建 key_selector.py → 运行 → 通过 ✅
2. 添加 get_next_key() → 运行 → 通过 ✅
3. 添加 mark_failed() → 运行 → 报错 ❌
   → 修复：忘记加锁 → 运行 → 通过 ✅
4. 集成到 translator.py → 运行 → 通过 ✅
```

#### ⑤ 验收阶段

**目标**：确认功能符合预期

**步骤**：
1. 运行完整功能测试
2. 让审核 AI Review 代码
3. Git 提交代码
4. 更新项目文档

**案例**：
```
功能测试：
- 测试 3 个 Key 轮询：通过 ✅
- 测试 Key 失败切换：通过 ✅
- 测试全部 Key 失效：通过 ✅

审核 AI Review：
✅ 代码符合规范
✅ 无硬编码
✅ 日志已国际化

Git 提交：
feat: 添加多 Key 轮询支持

文档更新：
- 更新功能列表
- 添加配置说明
```

---

## AI 协作模式

### 推荐模式：1 主 AI + 1 审核 AI + 1 IDE

```
┌─────────────────────────────────────────────────────────────────┐
│                        AI 协作架构                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐                                                │
│  │  项目文档    │ ← 单一真相来源                                 │
│  └──────┬──────┘                                                │
│         │                                                        │
│    ┌────┴────┬──────────┐                                       │
│    ↓         ↓          ↓                                        │
│  ┌─────┐  ┌─────┐  ┌─────────┐                                  │
│  │主 AI│  │审核AI│  │ IDE     │                                  │
│  │设计 │  │审查 │  │ 执行    │                                  │
│  └─────┘  └─────┘  └─────────┘                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 角色分工

| 角色 | 职责 | 推荐工具 |
|------|------|----------|
| **主 AI** | 设计方案、写代码、解答问题 | Claude / Gemini |
| **审核 AI** | Review 代码、检查遗漏 | 另一个 AI |
| **IDE** | 执行代码、显示错误 | Cursor / VS Code |

### 协作原则

| 原则 | 说明 |
|------|------|
| **每次对话先同步上下文** | 让 AI 先读项目文档 |
| **重要决定记录到文档** | 不要只口头约定 |
| **不同 AI 不要同时改一个文件** | 避免冲突 |
| **有疑问先问不要猜** | 宁可多问一句 |

---

## 检查清单

### 新功能检查清单

#### 规划阶段
- [ ] 这个功能是 MVP 必须的吗？
- [ ] 能用现有功能组合实现吗？
- [ ] 会影响现有架构吗？
- [ ] 预计工作量多少？

#### 设计阶段
- [ ] 符合单一职责原则吗？
- [ ] 需要加锁吗？
- [ ] 国际化：所有文本用 t() 包装了吗？
- [ ] 日志：日志消息国际化了吗？
- [ ] 配置：有硬编码吗？

#### 开发阶段
- [ ] 每步都测试了吗？
- [ ] 错误有记录日志吗？
- [ ] IDE 没有报错和警告？

#### 验收阶段
- [ ] 功能测试通过了吗？
- [ ] 审核 AI Review 过了吗？
- [ ] Git 提交了吗？
- [ ] 文档更新了吗？

---

## 案例演示

### 案例：添加 Cookie 轮换功能

#### 第一步：需求阶段

```
用户想法：
"Cookie 用一段时间就失效了，能不能自动换？"

AI 整理后的需求：
- 目标：支持多个 Cookie 自动轮换
- 解决问题：单 Cookie 被限流
- 范围：字幕下载模块
- 验收标准：
  1. 支持配置多个 Cookie 文件
  2. 自动选择健康的 Cookie
  3. 失效的 Cookie 自动禁用
  4. 一段时间后自动恢复
```

#### 第二步：设计阶段

```
主 AI 设计：
1. 创建 CookieRotator 类
2. 用文件名作为 Cookie 标识
3. 记录每个 Cookie 的成功/失败次数
4. 连续失败 3 次暂时禁用
5. 30 分钟后自动恢复

检查清单：
☑ 单一职责：只管 Cookie 轮换
☑ 加锁：需要，多线程访问
☑ 国际化：日志消息需要国际化
☑ 配置：Cookie 路径从配置读取

审核 AI Review：
✅ 设计合理
⚠️ 建议：添加冷却期，每次使用后休息 60 秒
```

#### 第三步：执行阶段

```
步骤 1：创建 cookie_rotator.py
- 写类定义 → 测试 → 通过 ✅

步骤 2：添加 get_healthy_cookie()
- 写方法 → 测试 → 通过 ✅

步骤 3：添加 mark_failed()
- 写方法 → 测试 → 报错 ❌
- 原因：忘记初始化 last_fail
- 修复 → 测试 → 通过 ✅

步骤 4：集成到下载模块
- 修改 downloader.py → 测试 → 通过 ✅
```

#### 第四步：验收阶段

```
功能测试：
- 测试 3 个 Cookie 轮换 → 通过 ✅
- 测试失效自动禁用 → 通过 ✅
- 测试 30 分钟后恢复 → 通过 ✅
- 测试冷却期 → 通过 ✅

Git 提交：
feat: 添加 Cookie 轮换支持

文档更新：
- 添加 Cookie 配置说明
- 添加文件命名规范
```

---

## 常见陷阱

### 陷阱 1：功能贪心

| 症状 | 解决 |
|------|------|
| 不断添加新功能 | 问自己：这是 MVP 必须的吗？ |
| 每个功能都想做到完美 | 先做能用的，后做好用的 |

### 陷阱 2：外行指挥内行

| 症状 | 解决 |
|------|------|
| 强行要求某种实现方式 | 说目标，让 AI 选方案 |
| 不听 AI 的警告 | 认真考虑，有疑问就追问 |

### 陷阱 3：不测试

| 症状 | 解决 |
|------|------|
| 改完一堆才测试 | 每改 10 行就测试 |
| 测试失败就跳过 | 立即修复，不要拖延 |

### 陷阱 4：多 AI 各自为政

| 症状 | 解决 |
|------|------|
| 每个 AI 记忆不同 | 建立统一项目文档 |
| 同时让多个 AI 改同一文件 | 一个改，另一个 Review |

### 陷阱 5：硬编码

| 症状 | 解决 |
|------|------|
| 文本写在代码里 | 使用 t() 函数 |
| 配置写在代码里 | 使用配置文件 |
| 路径写死 | 使用 Path 或配置 |

---

## 总结

### 黄金法则

```
1. 想法 → 写入项目文档
2. 让主 AI 设计方案
3. 对照检查清单审核
4. 让 IDE 执行
5. 每步测试
6. 让审核 AI Review
7. 通过 → Git 提交
8. 更新文档
9. 下一个功能
```

### 记住

> **规范先行，小步快跑，频繁测试，及时记录**
