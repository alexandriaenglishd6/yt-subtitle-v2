# YouTube 字幕工具 v2 - 完整处理流程详解

本文档详细说明从用户点击"开始处理"按钮后，整个系统的完整处理流程和逻辑。

## 一、UI 层：用户交互入口

### 1.1 点击"开始处理"按钮

**位置**: `ui/main_window.py` -> `_on_start_processing()`

**流程**:
1. 检查是否可以开始任务（`_check_can_start_task`）
2. 设置 `is_processing = True`
3. 更新按钮状态（显示"取消"按钮，隐藏"开始"按钮）
4. 创建安全回调函数（日志、状态、统计、完成）
5. 调用 `video_processor.process_videos()` 启动处理线程

---

## 二、业务逻辑层：VideoProcessor

**位置**: `ui/business_logic.py` -> `VideoProcessor`

### 2.1 初始化阶段（`__init__`）

1. **加载配置**: 从 `ConfigManager` 加载 `AppConfig`
2. **初始化核心组件**:
   - `ProxyManager`: 代理管理（可选）
   - `CookieManager`: Cookie 管理（可选）
   - `IncrementalManager`: 增量处理管理
   - `OutputWriter`: 输出写入器
   - `FailureLogger`: 失败记录器
3. **初始化 AI 客户端**:
   - `translation_llm_client`: 翻译 AI（根据配置创建）
   - `summary_llm_client`: 摘要 AI（根据配置创建）
   - 如果初始化失败，记录错误信息但不中断启动

### 2.2 获取视频列表

**方法**: `_detect_subtitles()` 或 `_get_video_list()`

**流程**:
1. 创建 `VideoFetcher` 实例
2. 根据 URL 类型（频道/播放列表/单视频）调用相应方法:
   - `get_channel_videos()`: 获取频道视频列表
   - `get_playlist_videos()`: 获取播放列表视频列表
   - `get_single_video()`: 获取单视频信息
3. 返回 `List[VideoInfo]`

### 2.3 完整处理流程

**方法**: `_run_full_processing()`

**流程**:
1. **重置取消令牌**: `self.cancel_token = CancelToken()`（每次新任务都创建新令牌）
2. **获取 Archive 路径**: 通过 `IncrementalManager` 获取或创建频道/播放列表的 archive 文件路径
3. **初始化统计信息**: `{"total": len(videos), "success": 0, "failed": 0, "current": 0}`
4. **调用核心流水线**: `process_video_list()`（见下文）
5. **更新统计信息**: 包含错误分类统计
6. **记录完成消息**: 显示成功/失败统计

---

## 三、核心流水线层：Pipeline

**位置**: `core/pipeline.py`

### 3.1 批量处理入口：`process_video_list()`

**流程**:
1. **生成 run_id**: 批次 ID，格式 `YYYYMMDD_HHMMSS`，用于日志追踪
2. **设置日志上下文**: 设置全局日志上下文（run_id, task）
3. **创建任务列表**: 为每个视频创建一个任务函数（闭包捕获 video 对象）
4. **创建 TaskRunner**: 使用配置的并发数（默认 10）
5. **执行并发任务**: 调用 `TaskRunner.run_tasks()`，每个任务调用 `process_single_video()`
6. **进度回调**: 定期更新进度、计算 ETA、检查取消状态
7. **返回统计结果**: `{"total": 总数, "success": 成功数, "failed": 失败数, "errors": 错误列表}`

### 3.2 单视频处理：`process_single_video()`

**这是核心处理函数，按顺序执行以下步骤**:

#### 步骤 1: 字幕检测（Detect）

**位置**: `core/pipeline.py:114-142`

**流程**:
1. 检查取消状态（如果已取消，抛出 `TaskCancelledError`）
2. 创建 `SubtitleDetector` 实例
3. 调用 `detector.detect(video_info)`
   - 使用 yt-dlp 检测视频的字幕信息
   - 返回 `DetectionResult` 对象（包含人工字幕语言列表、自动字幕语言列表、是否有字幕等）
4. **检查结果**:
   - 如果 `detection_result.has_subtitles == False`:
     - 记录警告日志
     - 记录失败（错误类型: `CONTENT`）
     - 返回 `False`（任务失败）
   - 如果有字幕，继续下一步

**输出**: `detection_result`（字幕检测结果）

---

#### 步骤 2: 字幕下载（Download）

**位置**: `core/pipeline.py:144-181`

**流程**:
1. 检查取消状态
2. 创建 `SubtitleDownloader` 实例
3. **创建临时目录**: `temp/{video_id}/`
4. 调用 `downloader.download()`:
   - **输入**: `video_info`, `detection_result`, `language_config`, `temp_dir`
   - **流程**:
     a. 确定源语言（优先人工字幕，其次自动字幕）
     b. 下载原始字幕: `original.{source_lang}.srt` -> `temp/{video_id}/`
     c. 对每个目标语言，检查是否有官方翻译字幕:
        - 如果有官方字幕（人工或自动），下载到 `temp/{video_id}/translated.{target_lang}.srt`
        - 如果没有官方字幕，不下载（后续由翻译步骤处理）
   - **返回**: `download_result` 字典
     ```python
     {
         "original": Path,  # 原始字幕文件路径（temp 目录）
         "official_translations": {
             "zh-CN": Path,  # 官方翻译字幕路径（如果存在）
             ...
         }
     }
     ```
5. **检查结果**:
   - 如果 `download_result.get("original")` 为 `None` 或不存在:
     - 记录错误日志
     - 记录失败（错误类型: `NETWORK`）
     - 返回 `False`

**输出**: `download_result`（下载结果字典）

**重要**: 所有下载的文件都保存在 `temp/{video_id}/` 目录中，**尚未写入输出目录**

---

#### 步骤 3: 字幕翻译（Translate）【已优化】

**位置**: `core/pipeline.py:183-285`

**优化说明**: 在 pipeline 层面统一判断，避免不必要的函数调用和重复文件操作

**流程**:
1. 检查取消状态
2. **在 Pipeline 层面分类语言**（优化点）:
   - 对每个目标语言，检查是否有官方字幕（从 `download_result["official_translations"]` 获取）
   - **AI_ONLY 策略或强制重译（force=True）**:
     - 所有语言都需要翻译（忽略官方字幕）
   - **其他策略（OFFICIAL_ONLY / OFFICIAL_AUTO_THEN_AI）**:
     - 有官方字幕且 `force=False`：直接使用官方字幕，加入 `translation_result`
     - 无官方字幕：加入 `needs_translation` 列表
   - **如果所有语言都有官方字幕**：完全跳过翻译步骤，直接使用官方字幕
3. **只翻译需要的语言**:
   - 如果 `needs_translation` 为空：跳过翻译步骤
   - 如果 `needs_translation` 不为空：
     - 如果 `translation_llm` 为 `None`：
       - 检查是否需要 AI 翻译（根据策略）
       - 如果需要但 LLM 不可用，记录警告
     - 如果 `translation_llm` 存在：
       - 创建 `SubtitleTranslator` 实例
       - 调用 `translator.translate()`，**只翻译 `needs_translation` 列表中的语言**
       - **翻译步骤内部**（只处理需要翻译的语言）:
         a. 检查是否已存在翻译文件（如果 `force=False` 且存在，跳过）
         b. 检查是否有官方字幕（理论上不应该发生，因为 pipeline 已筛选）
         c. 根据翻译策略决定是否调用 AI:
            - `OFFICIAL_ONLY`: 不调用 AI，如果没有官方字幕则返回 `None`
            - `OFFICIAL_AUTO_THEN_AI`: 调用 AI
            - `AI_ONLY`: 调用 AI（忽略官方字幕）
         d. 如果需要 AI 翻译:
            - 读取原始字幕文件
            - 生成翻译 Prompt
            - 调用 `llm.generate()`
            - 保存到 `temp/{video_id}/translated.{target_lang}.srt`
       - 合并翻译结果：`translation_result.update(partial_result)`
4. **检查翻译结果**:
   - 收集缺失的目标语言（没有翻译结果的）
   - 如果策略是 `OFFICIAL_ONLY` 且缺失，记录失败并返回 `False`
   - 其他策略下，翻译失败不视为整体失败，继续处理

**输出**: `translation_result`（包含官方字幕和 AI 翻译的结果）

**优化效果**:
- ✅ 避免了不必要的函数调用（如果有官方字幕，直接跳过翻译步骤）
- ✅ 避免了重复的文件复制（官方字幕已在正确位置，无需再次复制）
- ✅ 逻辑更清晰（在 pipeline 层面统一判断）
- ✅ 只翻译需要的语言（部分语言有官方字幕时，只翻译没有官方字幕的语言）

---

#### 步骤 4: 生成摘要（Summarize）

**位置**: `core/pipeline.py:285-324`

**流程**:
1. **检查条件**: 需要同时满足:
   - 有翻译结果或原始字幕
   - `summary_llm` 不为 `None`
2. 检查取消状态
3. 创建 `Summarizer` 实例
4. 调用 `summarizer.summarize()`:
   - **输入**: `video_info`, `language_config`, `translation_result`, `download_result`, `temp_dir`
   - **流程**:
     a. 选择摘要源文本（优先翻译后的字幕，其次原始字幕）
     b. 读取字幕文件，提取纯文本（去除时间轴）
     c. 生成摘要 Prompt（通过 `get_summary_prompt()`）
     d. 调用 `llm.generate()` 生成摘要
     e. 保存摘要到 `temp/{video_id}/summary.{summary_lang}.md`
   - **返回**: `summary_path`（摘要文件路径，在 temp 目录中）
5. **检查结果**: 如果摘要生成失败，记录失败但不中断任务

**输出**: `summary_path`（摘要文件路径，可能为 `None`）

---

#### 步骤 5: 写入输出文件（Output）

**位置**: `core/pipeline.py:326-362`

**流程**:
1. **检查 Dry Run**: 如果是 Dry Run 模式，跳过写入
2. 调用 `output_writer.write_all()`:
   - **输入**: `video_info`, `detection_result`, `language_config`, `download_result`, `translation_result`, `summary_path`
   - **流程**:
     a. **获取输出目录**: `out/{channel_name}/{video_id}/` 或 `out/playlist/{playlist_id}/{video_id}/` 或 `out/videos/{video_id}/`
     b. **写入原始字幕**:
        - 读取 `temp/{video_id}/original.{source_lang}.srt`
        - 写入到 `{output_dir}/original.{source_lang}.srt`
        - 返回输出目录中的路径 `output_original_path`
     c. **写入翻译字幕**:
        - 对每个翻译结果，读取 `temp/{video_id}/translated.{target_lang}.srt`
        - 写入到 `{output_dir}/translated.{target_lang}.srt`
        - 保存输出目录中的路径到 `output_translated_paths`
     d. **写入双语字幕**（如果启用）:
        - 如果 `bilingual_mode == "source+target"`:
          - 对每个目标语言:
            - 使用 `output_original_path` 作为源语言字幕路径
            - 使用 `output_translated_paths[target_lang]` 作为目标语言字幕路径
            - 调用 `write_bilingual_subtitle()` 合并并写入 `{output_dir}/bilingual.{source}-{target}.srt`
            - **注意**: 这里使用的是输出目录中的路径，不是 temp 目录！
     e. **写入摘要**（如果存在）
     f. **写入元数据**: `metadata.json`
   - **返回**: `video_dir`（输出目录路径）

**重要**: 这一步是**唯一**将文件从 temp 目录复制到输出目录的地方！

---

#### 步骤 6: 更新增量记录（Archive）

**位置**: `core/pipeline.py:364-375`

**流程**:
1. 如果处理成功（`processing_failed == False`）:
   - 调用 `incremental_manager.mark_as_processed(archive_path, video_info)`
   - 写入到 archive 文件（格式: `youtube {video_id}`）
2. 如果处理失败:
   - 不更新 archive（下次运行仍会处理）

---

#### 步骤 7: 清理临时目录（Cleanup）

**位置**: `core/pipeline.py:376-381`（finally 块）

**流程**:
1. 无论成功或失败，都会执行清理
2. 删除 `temp/{video_id}/` 目录及其所有内容

**重要**: 清理是在 `finally` 块中执行的，确保即使发生异常也会清理

---

## 四、关键数据流

### 4.1 文件路径流转

```
1. 下载阶段:
   yt-dlp -> temp/{video_id}/original.{lang}.srt
   yt-dlp -> temp/{video_id}/translated.{lang}.srt (官方字幕)

2. 翻译阶段:
   temp/{video_id}/original.{lang}.srt -> AI -> temp/{video_id}/translated.{lang}.srt

3. 输出阶段:
   temp/{video_id}/original.{lang}.srt -> out/{channel}/{video_id}/original.{lang}.srt
   temp/{video_id}/translated.{lang}.srt -> out/{channel}/{video_id}/translated.{lang}.srt
   out/{channel}/{video_id}/original.{lang}.srt + translated.{lang}.srt -> bilingual.{source}-{target}.srt

4. 清理阶段:
   删除 temp/{video_id}/ 目录
```

### 4.2 关键字典结构

**download_result**:
```python
{
    "original": Path("temp/{video_id}/original.{source_lang}.srt"),
    "official_translations": {
        "zh-CN": Path("temp/{video_id}/translated.zh-CN.srt"),  # 可选
        ...
    }
}
```

**translation_result**:
```python
{
    "zh-CN": Path("temp/{video_id}/translated.zh-CN.srt"),  # AI 翻译或官方字幕
    "en-US": Path("temp/{video_id}/translated.en-US.srt"),
    ...
}
```

### 4.3 错误处理机制

- **AppException**: 统一的异常类型，包含 `error_type`（`ErrorType` 枚举）
- **错误分类**: `NETWORK`, `AUTH`, `RATE_LIMIT`, `CONTENT`, `FILE_IO`, `TIMEOUT`, `UNKNOWN`
- **失败记录**: 通过 `FailureLogger` 记录到 `failed_records.json` 和 `failed_urls.txt`
- **错误统计**: 在最终结果中返回 `error_counts` 字典，按错误类型统计

---

## 五、并发执行机制

### 5.1 TaskRunner

- 使用 `ThreadPoolExecutor` 实现线程池
- 默认并发数 10（可配置）
- 每个视频的处理是独立的，互不干扰
- 进度回调定期更新，包含 ETA 计算

### 5.2 取消机制

- 使用 `CancelToken` 对象传递取消状态
- 每个步骤开始时检查 `cancel_token.is_cancelled()`
- 如果已取消，抛出 `TaskCancelledError`（继承自 `AppException`）
- TaskRunner 会捕获异常并正常结束

---

## 六、常见问题排查

### 6.1 双语字幕生成失败

**错误**: "源语言字幕文件为空"

**可能原因**:
1. 使用 temp 目录中的路径（但文件可能已被清理或不存在）
2. 文件存在但内容为空或格式不正确
3. SRT 解析正则表达式无法匹配文件格式

**解决方案**:
- 使用输出目录中的文件路径（`output_original_path`）
- 检查文件内容，确保是有效的 SRT 格式
- 添加文件内容预览到错误消息

### 6.2 翻译失败但任务继续

**行为**: 翻译失败不视为整体失败（除了 `OFFICIAL_ONLY` 策略）

**原因**: 允许部分语言翻译失败，其他步骤可以继续

### 6.3 临时目录清理

**时机**: 无论成功或失败，都会在 `finally` 块中清理

**注意**: 如果在处理过程中查看 temp 目录，可能会看到中间文件，但处理完成后会被清理

---

## 七、配置影响

### 7.1 翻译策略

- **AI_ONLY**: 总是调用 AI，忽略官方字幕
- **OFFICIAL_AUTO_THEN_AI**: 优先官方，无则 AI（默认）
- **OFFICIAL_ONLY**: 只用官方，不调用 AI

### 7.2 双语模式

- **none**: 不生成双语字幕
- **source+target**: 生成双语字幕（源语言/目标语言）

### 7.3 强制重跑（force）

- 如果 `force=True`:
  - 忽略 archive 记录（处理所有视频）
  - 忽略已存在的翻译文件（重新翻译）
  - 忽略已存在的摘要文件（重新生成）

---

## 八、日志追踪

- **run_id**: 批次 ID，格式 `YYYYMMDD_HHMMSS`
- **task**: 当前任务阶段（`detect`, `download`, `translate`, `summarize`, `output`）
- **video_id**: 视频 ID
- 所有日志都会包含这些上下文信息，方便追踪

---

## 总结

整个流程严格按照以下顺序执行：

1. **检测** -> 2. **下载** -> 3. **翻译** -> 4. **摘要** -> 5. **输出** -> 6. **归档** -> 7. **清理**

每个步骤都有错误处理，只有严重错误（如无字幕、下载失败、OFFICIAL_ONLY 策略下无官方字幕）才会中断单个视频的处理。翻译失败和摘要失败不会中断任务，只会记录失败信息。

文件的流转：temp 目录用于中间处理，输出目录用于最终结果，处理完成后清理 temp 目录。

