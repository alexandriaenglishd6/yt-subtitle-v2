下面是按你最新要求改写后的 v2_final_plan.md 完整版本（已经把 Dry Run、增量、多语言、并发/代理这些容易误解的地方全写死了，也放宽了代理数量上限，不在代码层面锁死）——你可以直接复制粘贴成文件。

```markdown
# yt-subtitle-v2 终极完整规划方案  
2025-12-07 最终定稿版（修订）

---

## 一、项目宣言（写进 README 第一行）

> 一个只为「我要把整个 YouTube 频道的字幕变成**我需要的语言摘要和双语字幕**」而生的极简、极快、尽量不翻车的个人神器。  
> 一条频道链接，一键到底，1000+ 视频也不怕，从此告别臃肿老项目。

（说明：这里刻意没有写死“中文”，因为 V2 从设计上就要支持任意目标语言和未来多语言扩展。）

---

## 二、核心用户场景（99.9% 的真实用法）

典型使用路径：

```text
打开软件 → 粘贴频道 URL → 点【检查新视频】 → 看到“新增 38 个有字幕的视频” 
→ 点【开始处理】 → 喝杯水 → 回来看到「成功 327，失败 12」
→ 所有字幕 + 摘要都整整齐齐躺在 out/ 对应文件夹中
````

三、功能最终清单（按优先级）
P0 = MVP 必须实现\
P1 = MVP 完成后第一轮增强\
P2 = 以后真用爽了再加
3.1 功能总表
优先级 功能 状态 备注 P0 MVP 频道全量视频获取 必有 基于 yt-dlp 获取频道全部视频 ID/URL P0 字幕检测（人工 / 自动分离） 必有 单视频检测：是否有字幕 + 人工/自动语言列表 P0 Dry Run（仅检测，日志输出） 必有 仅检测字幕并输出到日志，不下载、不摘要、不写报告文件 P0 增量处理（只处理新视频） 必有 优先使用 yt-dlp --download-archive 记录已处理视频 P0 字幕下载 必有 优先官方字幕 → 官方自动翻译 → 最后才用 AI 翻译（受配置控制） P0 AI 摘要（单一目标语言，可配置） 必有 Prompt 模板集中管理，不写死“中文” P0 统一输出目录结构 必有 使用语言代码命名，保证未来多语言也不需要改结构 P0 Cookie 一键粘贴 + 测试按钮 + 状态显示 必有 显示“是否可用/地区”，不强行预估有效期 P0 多代理支持（数量不锁死） + 并发可配置 必有 UI 放开，代码不强制上限，但文档给推荐范围 P0 失败静默写入 out/failed.txt 必有 失败不弹窗，中断原因写入单独文件 P0 每次新任务自动清空上一次进度计数 必有 UI 计数/进度在新任务开始时清零 P0 配置自动保存到用户目录 必有 如 %APPDATA%/yt-subtitle-v2/config.json P0 中英双语 UI + 4 套主题 必有 白、浅灰、深灰、Claude 暖色；所有文案 i18n P0 CLI 入口 + 基础烟雾测试脚本 必有 方便自动化与回归测试 P1 双语字幕（可选） 可选必做 原文 + 目标语言，对照输出 P1 批量 URL 列表处理（非频道） 可选必做 文本框直接粘贴多行 URL P1 增量策略高级选项 可选 允许选择“全量重跑”等模式 P2 多语言摘要 / 更多 UI 语言 可选 用着爽了再加 P2 Dry Run 检测报告文件 + “一键继续处理” 可选 必须在更新规划后才实现

## 四、输出与数据目录结构（稳定版本）

> 区分两类目录：
> - `out/`：只放用户输出结果（字幕、摘要等），你可以随时备份或清空；
> - 用户数据目录（如 `%APPDATA%/yt-subtitle-v2/`）：放配置和增量记录，这是程序的“记忆”，不建议随便删。

### 4.1 输出目录：`out/`（结果，可删）

```text
out/
├── 单个视频或批量 URL 模式
│   └── dQw4w9WgXcQ  Never Gonna Give You Up/
│       ├── original.en.srt                    # 原始字幕（original.<source_lang>.srt）
│       ├── translated.zh-CN.srt               # 翻译字幕（translated.<target_lang>.srt）
│       ├── bilingual.en-zh-CN.srt             # 可选：双语字幕（bilingual.<source>-<target>.srt）
│       ├── summary.zh-CN.md                   # 摘要（summary.<summary_lang>.md）
│       └── metadata.json                      # 元数据（视频标题、ID、检测信息等）
│
├── 频道批量模式
│   └── 频道名称 [UCxxxxxx]/
│       ├── dQw4w9WgXcQ  .../                  # 每个视频一个子目录，与上面结构相同
│       └── ...                                # 其他视频
│
└── failed.txt                                 # 全局失败链接清单（本轮及历史追加）
failed.txt：

每行一条失败记录，建议包含时间、频道 ID、视频 ID、URL、失败原因；

位于 out/ 根目录，便于你在文件管理器中直接发现；

属于“输出的一部分”，你清空 out/ 时一起删除是合理行为。

bash
复制代码

### 4.2 用户数据目录：配置与增量记录（程序记忆，不建议删）

```text
# Windows 示例路径：
%APPDATA%/yt-subtitle-v2/
# Linux：
~/.config/yt-subtitle-v2/
# macOS：
~/Library/Application Support/yt-subtitle-v2/

结构示例：
yt-subtitle-v2-data/
├── config.json              # 所有可持久化配置（语言、并发、代理、AI 模型、输出路径等）
├── archives/                # 频道增量记录（避免重复处理）
│   ├── UCxxxxxx.txt         # 某个频道的已处理视频列表（可用 yt-dlp --download-archive 格式）
│   └── UCyyyyyy.txt
└── logs/                    # （可选）更长期的日志
    ├── app.log
    └── failed.log           # （可选）长期失败记录（与 out/failed.txt 可以重复一部分）
增量记录（archives）：

再次处理同一频道时，通过 UCxxxxxx.txt 判断哪些视频已经处理过，只处理新增部分；

不随着 out/ 的清空而被删除，避免“删除输出 → 下次又全量跑一遍”的坑；

只有在你明确希望“全量重跑”该频道时，才会手动删除对应 UCxxxxxx.txt 或通过 UI 提供的“全量重置”操作删除。

yaml
复制代码

你把这段贴回规划文档，之后跟 IDE / 其他 AI 讨论时，就不会再有人把 `archive.txt` 塞回 `out/` 里去了。

---

## 5. 并发 + 多 IP 最后再帮你强调一句设计原则

你刚才说得很对：**对我们这个场景，真正大的瓶颈是 YouTube 的反爬机制**，而不是你电脑多强或者网多快。

所以规划里对并发/代理的设计已经是这样：

- 并发：  
  - 默认 3；  
  - UI 让你改，但不硬性上限，只在超过一定值时提示“有封号风险”；  
- 代理：  
  - 列表长度理论上不限；  
  - 文档推荐：普通个人用户 1–5 个就够，极客玩家可以加更多，但风险自负。

之后 IDE 在实现时，也要遵守这个原则：**不在代码里写死 “max_proxies = 5” 或 “max_concurrency = 10” 这种硬上限**，只做合法性校验 + 日志/界面提示。


五、语言与国际化设计（LanguageConfig）
V2 明确区分：

* UI 语言（用什么语言显示界面）

* 字幕翻译目标语言（字幕要翻成什么）

* 摘要语言（摘要用什么语言写）

* 双语字幕模式

* 翻译策略（优先官方字幕 / 官方自动翻译 / 纯 AI）

5.1 LanguageConfig 模型（示意）

```python
class LanguageConfig:
    ui_language: str                      # 界面语言，如 "zh-CN" / "en-US"
    subtitle_target_languages: list[str]  # 字幕翻译目标语言列表，如 ["zh-CN"] 或 ["zh-CN", "en-US"]
    summary_language: str                 # 摘要使用的单一语言，如 "zh-CN"
    bilingual_mode: Literal["none", "source+target"]
    translation_strategy: Literal[
        "AI_ONLY",                 # 总是用 AI 翻译
        "OFFICIAL_AUTO_THEN_AI",   # 优先官方字幕/自动翻译，无则用 AI
        "OFFICIAL_ONLY"            # 只用官方多语言字幕，不调用 AI
    ]
```

要求：

* 不允许在代码中硬编码 “翻译成中文 / 请用中文摘要”，所有语言选择必须从 LanguageConfig 得到。

* UI 语言 ui_language 可以和 summary_language 不同（比如界面中文、摘要英文）。

* 字幕目标语言可以是多个，虽然第一版 UI 可以只暴露一个简单选择，但底层结构要支持多语言，避免以后大改。

5.2 AI Prompt 模板集中管理

* 所有 AI prompt 放在统一模块中，比如 core/prompts.py；

* 模板使用占位符，如 {target_language_name}，生成时由 LanguageConfig 注入：

  * summary_language = "zh-CN" → target_language_name = "中文"

  * summary_language = "en-US" → target_language_name = "English"

* 禁止在各处散落写“请用中文总结…”。

六、并发 & 代理 / Cookie 设计
6.1 并发设计原则
并发瓶颈主要来自三方面：

1. 电脑硬件（CPU / 内存 / I/O）

2. 网络质量（带宽 / 延迟 / 丢包）

3. YouTube 的反爬机制（最关键）

设计目标：

* 默认配置对大多数用户安全可靠；

* 高阶用户可以自主提高并发和代理数量以追求极限速度；

* 工具不在代码层面“锁死上限”，但通过文档和 UI 提示给出推荐范围。

具体约定：

* concurrency：任务并发度

  * 默认值：3

  * UI 中允许用户输入任意正整数（如输入框），不强制硬上限；

  * 实现上可做一些安全校正（负数/0 → 1）；

  * 当用户设置超过推荐值（例如 > 10 或 > 20）时，仅通过 UI/日志给出警告：
    “并发过高可能导致 IP 封锁 / 429，请谨慎使用。”

6.2 代理 IP 设计

* 代理主要用于：

  * 分散请求，减轻单 IP 压力，降低被 YouTube 限制的风险；

  * 访问地区限制内容。

* 数量不锁死：

  * 配置中 proxies 是一个列表，理论上无限长；

  * 文档推荐范围：

    * 一般个人使用：1–5 个高质量代理就足够

    * 重度用户可视情况增加（如 10+），但风险自负；

  * UI 中不限制输入行数，只在提示文字里说明推荐范围。

简单代理健康管理：

* 每个代理记录：

  * 最近连续失败次数

  * 最后错误原因

  * 最后成功时间

* 连续失败超过阈值（例如 3 次）：

  * 标记为 unhealthy，优先跳过使用；

  * 一段时间后（例如 10 分钟）可以尝试一次“探测请求”，成功则恢复健康状态。

* 不实现复杂评分公式与图表监控。

6.3 Cookie 支持

* UI 提供：

  * Cookie 文本输入框；

  * [粘贴] 按钮；

  * [清空] 按钮；

  * [立即测试] 按钮：

    * 尝试访问一个简单页面，返回“是否可用、所处地区”等信息。

* 不强行实现“剩余有效期”估算，只显示当前可用性与地区信息即可。

七、Dry Run / 增量 / 摘要语言 —— 关键概念说明
7.1 Dry Run（仅检测模式）
定义：
Dry Run = 只做“字幕检测”，用于安全预览和调试，不触发任何下载、翻译、摘要、不写任何报告文件、不更新增量状态。
Dry Run 模式下：

* ✅ 可以：

  * 获取频道所有视频列表；

  * 对每个视频检测：有无字幕、人工字幕语言、自动字幕语言；

  * 将检测结果写入日志系统（控制台 / UI 日志框）；

* ❌ 不可以：

  * 下载字幕文件；

  * 调用翻译 / AI 摘要；

  * 写出 plan.md / detection_report.json 之类的报告文件；

  * 更新增量索引 / archive 文件；

  * 自动弹出“一键继续处理”的窗口。

说明：\
“检测报告 JSON + 一键继续处理”作为未来 P2 功能，只有在本规划文档更新并明确你同意后，才允许实现。
7.2 增量检测
核心语义：
再次处理同一频道时，默认只对“以前没处理过的视频”执行完整流水线，避免重复处理。
实现建议：

* 优先使用 yt-dlp --download-archive archive.txt：

  * 第一次处理：

    * archive 文件不存在 → 处理所有视频，并让 yt-dlp 记录已处理的 ID；

  * 后续处理：

    * 通过 archive 文件跳过已处理的视频，只触发新视频。

* 如果因技术原因需要自定义索引，也只记录“已处理视频 ID 列表”，不做复杂统计。

设计决策：

* 已删除的视频：

  * 不需要从索引中移除；

  * 保持“历史上处理过”的记录即可。

* 老视频后来加了新字幕：

  * 默认不会自动重新处理；

  * 需要重跑时，可以启用“全量重跑”选项清除/忽略旧索引。

Dry Run 与增量：

* Dry Run 模式下，不更新 archive / 索引，只做检测 + 日志输出。

7.3 摘要语言与多语言摘要
MVP 行为：

* 每个视频只生成 一份摘要文件；

* 摘要语言由 LanguageConfig.summary_language 决定，可配置为任意语言（zh-CN / en-US / …）；

* 摘要语言不必等于 UI 语言。

多语言摘要：

* 真正的“多语言摘要”（同一视频生成多种语言的摘要，例如中文 + 英文）被明确定义为 P2 功能；

* 在实现该功能前，必须先更新本规划文档并获得你的明确确认。

增量处理与强制重跑策略（方案 B）

本节补充说明：频道模式和视频链接模式下的增量规则，以及“强制重跑”的行为。
不实现“自动只补缺失输出”这种复杂智能逻辑，P0 阶段统一采用“增量 + 全局强制重跑开关”的简单可靠方案。

1. 适用范围

频道模式（输入频道 URL 或播放列表 URL）

视频链接模式 / URL 列表模式（输入若干视频 URL）

两种模式都要遵守同一套增量规则。

2. 增量的基本定义（默认行为）

增量处理 = 默认跳过「历史上已经成功处理过」的视频，不重复消耗时间和 AI 资源。

在用户数据目录中维护“已处理视频”的记录（例如 archives/UCxxxxxx.txt，或使用 yt-dlp --download-archive 文件）。

对于每次运行：

根据输入（频道 / URL 列表）解析出视频 ID 列表。

对每个视频 ID，查询增量记录：

若该视频 曾经成功完整地处理过，且当前运行未开启“强制重跑”→ 本次跳过该视频；

若该视频 从未被记录为成功处理 → 本次加入处理队列。

“成功处理”的含义：

下载字幕 + 翻译 + 摘要 + 输出文件结构都按配置完成，且未在本次运行中被判定为失败。

只要该视频被标记为成功，就视为可以被增量跳过。

默认情况下（未开启强制重跑），增量规则优先生效：

频道模式：第二次跑同一个频道时，只处理新增的视频；

URL 模式：再次提供相同视频 URL 时，若它已记录为成功处理，默认跳过。

3. 强制重跑（force）开关

用于覆盖增量规则，本次运行对所有输入的视频都重新处理，不参考历史记录。

在配置和 CLI / GUI 中提供一个全局布尔开关，例如：

CLI：--force / --force-reprocess

GUI：勾选框「忽略历史记录，强制重新处理这些视频」

当 force 为 true 时，本次运行行为为：

不使用任何增量记录，不读取 archives/ / download-archive 文件来跳过视频；

对本次输入的所有视频（频道/URL 列表解析出来的 ID），一律当作「从未处理过」来执行完整流水线：

重新下载字幕

重新调用 AI 翻译（如果策略允许）

重新调用 AI 摘要

重新写输出文件（可覆盖旧文件）

运行结束后，更新增量记录：这些视频会再次被标记为“已成功处理”。

用途示例：

用户误删了某个视频或整个频道的输出目录；

用户想用全新的翻译/摘要风格处理一轮（但不使用更细粒度的强制重译/重摘要开关时）。

4. Dry Run 与增量的关系

Dry Run 模式始终不更新任何增量记录：

Dry Run 只执行“字幕检测”，不判断成功/失败，不写入 archives/。

即使在 Dry Run 中启用 force（如果 CLI/GUI 允许），也只是改变“检测对象范围”（例如包括历史视频一起检测），仍然不会修改增量状态。

5. 不做的事情（P0 阶段刻意简化）

P0 阶段不实现以下复杂逻辑：

不自动检查输出目录是否缺失某些文件后“智能补齐”；

不为每个视频单独维护“只缺翻译 / 只缺摘要”等细粒度状态；

不在未开启 force 的情况下自动重跑“输出缺失的视频”。

若用户误删某个视频的输出，希望重新生成，只需：

再次提供该视频（频道或 URL）；

勾选（或指定）全局 force；

本次运行会完整重跑该视频的下载 / 翻译 / 摘要 / 输出流程。

八、UI 结构（不锁死布局，只约束元素）
UI 布局可以由你后续重新设计，这里只定义应该有的功能区域。
8.1 主窗口元素
大致包含：

* 频道/视频 URL 输入框

* 按钮：

  * 【检查新视频】（触发 Dry Run / 增量检测）

  * 【开始处理】（执行完整流水线）

  * 【打开输出文件夹】

* 下拉 / 选择：

  * 目标字幕语言（使用 subtitle_target_languages，UI 初版可以简化为“主目标语言”）

  * 摘要语言（绑定 summary_language）

  * 双语字幕勾选框

  * Dry Run 勾选框（高级区域也可）

* 代理与并发：

  * 代理输入框（多行，每行一个）

  * 并发数量输入框（默认 3，不锁死上限，只做警告）

* Cookie 区域：

  * 文本框

  * [粘贴] / [清空] / [立即测试]

  * 状态文本（可用/不可用、地区信息）

* 运行状态：

  * 成功计数 / 失败计数

  * 百分比进度

  * 预计剩余时间（可选）

* 日志输出框：

  * 实时显示检测结果、错误信息、Dry Run 输出等。

8.2 主题与语言切换

* 主题：

  * 只提供 4 个预设主题，基于统一的主题 token（bg/text/accent/border 等）实现；

* UI 语言：

  * 提供中/英切换；

  * 所有文案走 i18n（ui/i18n/zh_CN.json + en_US.json）。

九、仓库结构（V2 专用）
示例结构：

```text
yt-subtitle-v2/
├── core/
│   ├── pipeline.py        # 频道 → 检测 → 下载 → 翻译 → 摘要 → 输出
│   ├── downloader.py      # 下载 & 调用 yt-dlp
│   ├── translator.py      # 翻译逻辑（官方/AI）
│   ├── summarizer.py      # AI 摘要逻辑
│   ├── language.py        # LanguageConfig & 语言相关工具
│   ├── prompts.py         # 所有 AI prompt 模板
│   └── models.py          # 数据模型（VideoInfo、DetectionResult 等）
├── ui/
│   ├── main_window.py     # 主窗口 & 控件布局
│   ├── themes.py          # 4 套主题 + token 定义
│   └── i18n/
│       ├── zh_CN.json
│       └── en_US.json
├── config/
│   └── manager.py         # 配置模型 + 读写逻辑（用户目录）
├── cli.py                 # CLI 入口（支持频道/URL 模式）
├── out/                   # 所有输出（运行时自动创建）
├── tests/
│   └── test_smoke.py      # 基础烟雾测试 & 小频道回归
├── main.py                # GUI 入口
├── requirements.txt       # 尽量精简（<= 10 个核心依赖）
└── docs/
    └── v2_final_plan.md   # 就是这份规划
```

说明：

* v1 老项目代码视为 legacy，放在其他目录（本规划不再赘述），仅做参考和代码素材库；

* V2 所有新逻辑只放在上述结构中。

十、实施节奏（6 天交付示意）
这是理想节奏，实际可以按阶段推进。重点是“先跑通，再加花”。
天数 当天可跑功能 验收标准（你作为不会写代码的用户） 第 1 天 频道扫描 + 字幕检测 + Dry Run + 增量基础 + failed.txt 写入 对一个 100+ 视频频道，Dry Run 能在合理时间内（例如 1 分钟级）列出有字幕视频（只看日志）；两次运行第二次只显示新增视频。 第 2 天 全自动下载 + 翻译（单语言）+ 摘要 + 完整输出结构 选 10 个视频，跑完后 out/ 下有 10 个整齐的视频文件夹，结构符合第四节描述。 第 3 天 并发执行基础 + 多代理轮询 + Cookie 测试 + 配置保存 设置合理并发和代理，对一个 500 视频频道跑一次不崩；重启软件后配置自动恢复。 第 4 天 GUI 初版 + 中英切换 + 4 套主题 打开就是“第五节 UI 元素”那种布局；切换主题和语言无明显布局错乱。 第 5 天 双语字幕选项 + 增量高级选项 + 更完整错误提示 开双语字幕跑几条视频，能看到双语 .srt；故意断网时，日志有清晰错误信息，failed.txt 记录失败链接。 第 6 天 打包单个 EXE（可选）+ CLI 使用说明 可以打包成一个独立 EXE（或 PyInstaller 等方案）；同时 CLI 能独立跑完全流程。
十一、测试与验收（自动 + 手动）

* 提供 tests/test_smoke.py：

  * 使用一个固定的小频道 URL（例如 3–5 个视频）做集成测试；

  * 验证：检测 → 下载 → 翻译 → 摘要 → 输出 目录结构是否正确；

* IDE 每完成一个阶段的代码更改，都应：

  * 运行 smoketest 并汇报结果；

  * 你自己再按照上面“6 天验收标准”简单点一次界面。

十二、AI 翻译与 AI 摘要调用策略
本节规定：在何种情况下调用 AI 翻译 / AI 摘要，如何尽量利用官方字幕，如何避免重复调用，以及如何通过“强制重译/重摘要”重新生成结果。

前提：以下规则仅适用于非 Dry Run 模式。Dry Run 下永远不调用任何 AI，也不下载字幕。

1. 翻译策略总览

在 LanguageConfig 中存在：

translation_strategy: Literal[
    "AI_ONLY",                 # 总是用 AI 翻译
    "OFFICIAL_AUTO_THEN_AI",   # 优先官方（人工/自动翻译），无则用 AI
    "OFFICIAL_ONLY"            # 只用官方多语言字幕，不调用 AI
]


以及：

subtitle_target_languages: list[str]  # 例如 ["zh-CN"] 或 ["zh-CN", "en-US"]

2. 官方字幕优先规则

对每个视频、每个目标语言 L ∈ subtitle_target_languages，翻译流程如下：

优先使用官方字幕 / 官方自动翻译：

1.1 有官方人工字幕 = 目标语言 L：

直接下载并作为目标字幕使用；

在 OFFICIAL_ONLY、OFFICIAL_AUTO_THEN_AI 下均不调用 AI 翻译。

1.2 没有人工字幕，但有官方自动翻译字幕 = 目标语言 L：

直接下载并作为目标字幕使用；

同样在 OFFICIAL_ONLY、OFFICIAL_AUTO_THEN_AI 下不调用 AI 翻译。

当官方字幕不足以满足需求时：

若 translation_strategy == "OFFICIAL_ONLY"：

不调用 AI 翻译；

记录“目标语言 L 无可用官方字幕”的信息到日志 / failed.txt，视为该目标语言翻译不可用。

若 translation_strategy == "OFFICIAL_AUTO_THEN_AI" 或 "AI_ONLY"：

选择一个适合作为源的字幕轨作为翻译源（优先：人工字幕 → 自动字幕）；

调用 AI 翻译将源字幕翻译成目标语言 L；

生成 translated.<L>.srt 文件。

特别：AI_ONLY 模式下，可以选择忽略官方翻译，统一从某个源字幕轨调用 AI 翻译（由实现决定）。

3. 避免重复调用 AI 翻译

为了避免浪费 Token 和时间，对每个视频 + 目标语言 L，在准备调用 AI 翻译前必须：

检查输出目录中是否存在对应文件：

translated.<L>.srt

行为规则：

若文件存在，且本次运行 未启用“强制重译”（见下文）：

不得再次调用 AI 翻译；

直接认为该语言翻译已完成，跳过翻译步骤。

若文件不存在，或本次运行显式启用了“强制重译”：

按上述翻译策略决定是否调用 AI 翻译；

调用成功后生成/覆盖 translated.<L>.srt。

4. 强制重译（可选高级开关）

在全局配置中可以提供一个开关，例如：

force_retranslate: bool

语义：

当 force_retranslate == true 时：

即使 translated.<L>.srt 已存在，也强制重新调用 AI 翻译并覆盖输出；

可用于：

更换翻译风格 / prompt 后，希望全量重译；

修复之前翻译质量不佳的结果。

说明：全局 force（强制重跑）开关的语义更强：

force = true 时，本次运行会忽略增量记录，对所有视频重跑完整流水线（下载 + 翻译 + 摘要 + 输出）。

force_retranslate 可以在不重跑其他环节的前提下，只针对翻译阶段做强制刷新。

二者可以叠加使用，也可以只用其一。

5. AI 摘要调用规则

在 LanguageConfig 中有：

summary_language: str  # 单一摘要语言，如 "zh-CN" / "en-US" / "ja-JP"


MVP 行为：

每个视频仅生成一份摘要文件：

summary.<summary_language>.md

摘要来源选择：

摘要使用的源文本应尽量与 summary_language 一致：

若存在 translated.<summary_language>.srt：

优先用其作为摘要输入；

如不存在，可退回使用原始字幕或其他最合适的语言字幕（实现可自行选择优先级，但必须在文档/日志中说明策略）。

6. 避免重复调用 AI 摘要

在对某视频准备生成摘要前，必须：

检查是否已经存在摘要文件：

summary.<summary_language>.md

行为规则：

若文件存在，且本次运行 未启用“强制重生成摘要”：

不得再次调用 AI；

直接视为该视频摘要已完成，跳过摘要步骤。

若文件不存在，或启用了“强制重生成摘要”：

调用 AI 生成摘要，写入/覆盖 summary.<summary_language>.md。

7. 强制重生成摘要（可选高级开关）

在配置中增加开关，例如：

force_resummarize: bool

语义：

当 force_resummarize == true 时：

即使 summary.<summary_language>.md 已存在，也必须重新调用 AI 生成新的摘要并覆盖；

用途：

修改了摘要 Prompt / 风格模板之后，想让所有视频的摘要统一更新；

修复之前摘要质量问题。

与翻译类似，全局 force 可以用来“从头再跑一次所有东西”，
force_resummarize 则只针对摘要阶段进行强制刷新。

8. 多语言摘要（P2 功能）

当前版本（P0 / P1）中，每个视频只生成一种语言的摘要；

真正的多语言摘要（例如同时生成 summary.zh-CN.md + summary.en-US.md）明确为 P2 扩展功能；

在未更新本规范并经用户确认前，任何 AI / IDE 不得实现多语言摘要。
