"""
主窗口 & 控件布局
实现四区结构：顶部工具栏 + 左侧侧边栏 + 中间主区 + 底部日志框
"""
import customtkinter as ctk
from typing import Optional, Callable
from pathlib import Path
import threading

from core.logger import Logger, get_logger
from core.fetcher import VideoFetcher
from core.pipeline import process_video_list
from core.detector import SubtitleDetector
from core.output import OutputWriter
from core.incremental import IncrementalManager
from core.failure_logger import FailureLogger
from core.proxy_manager import ProxyManager
from core.cookie_manager import CookieManager
from core.ai_providers import create_llm_client
from core.llm_client import LLMException
from ui.themes import ThemeTokens, get_theme, ThemeName
from ui.i18n_manager import t, set_language, get_language, SUPPORTED_LANGUAGES
from config.manager import get_user_data_dir, ConfigManager
from datetime import datetime


class MainWindow(ctk.CTk):
    """主窗口类
    
    实现四区布局：
    - 顶部工具栏：应用标题、运行状态、功能按钮
    - 左侧侧边栏：导航菜单（任务、运行设置、外观 & 系统）
    - 中间主区：根据导航显示不同页面
    - 底部日志框：实时显示日志
    """
    
    def __init__(self):
        super().__init__()
        
        # 窗口基本设置（先设置默认标题，i18n 初始化后会更新）
        self.title("YouTube 字幕工具 v2")
        self.geometry("1200x800")
        self.minsize(800, 600)
        
        # 当前主题（从配置加载或使用默认值）
        self.current_theme: ThemeName = self._load_theme_from_config()
        self.theme_tokens: ThemeTokens = get_theme(self.current_theme)
        
        # 初始化 i18n（从配置读取语言设置）
        self._init_i18n()
        
        # 当前运行状态
        self.running_status = t("status_idle")
        
        # 当前模式（随主内容区变化）
        self.current_mode = t("channel_mode")
        
        # 防止循环调用的标志
        self._refreshing_theme_combo = False
        
        # 日志回调函数（用于从 Logger 接收日志）
        self.log_callback: Optional[Callable[[str, str, Optional[str]], None]] = None
        
        # 初始化 Logger（用于 GUI 日志输出）
        self.logger = Logger(name="gui", console_output=False, file_output=True)
        self.logger.add_callback(self._on_log_message)
        
        # 初始化配置管理器
        self.config_manager = ConfigManager()
        self.app_config = self.config_manager.load()
        
        # 初始化核心组件（延迟初始化，在需要时创建）
        self.video_fetcher: Optional[VideoFetcher] = None
        self.output_writer: Optional[OutputWriter] = None
        self.incremental_manager: Optional[IncrementalManager] = None
        self.failure_logger: Optional[FailureLogger] = None
        self.proxy_manager: Optional[ProxyManager] = None
        self.cookie_manager: Optional[CookieManager] = None
        self.llm_client = None  # LLMClient 可能为 None（如果 AI 不可用）
        
        # 处理状态
        self.is_processing = False
        self.processing_thread: Optional[threading.Thread] = None
        
        # 统计信息
        self.stats = {
            "total": 0,
            "success": 0,
            "failed": 0,
            "current": 0
        }
        
        # 构建 UI
        self._build_ui()
        
        # 应用主题
        self._apply_theme()
        
        # 初始化核心组件
        self._init_core_components()
    
    def _build_ui(self):
        """构建 UI 布局"""
        # 配置网格权重，使布局可伸缩
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        # 1. 顶部工具栏
        self._build_top_toolbar()
        
        # 2. 左侧侧边栏
        self._build_sidebar()
        
        # 3. 中间主内容区
        self._build_main_content()
        
        # 4. 底部日志框
        self._build_log_panel()
        
        # 5. 默认选中频道模式（在所有组件创建完成后）
        self._switch_page("channel")
        
        # 6. 刷新所有 UI 文本（确保使用正确的语言）
        self._refresh_ui_texts()
    
    def _init_i18n(self):
        """初始化 i18n，从配置读取语言设置"""
        try:
            # 尝试从配置读取语言设置
            config_manager = ConfigManager()
            app_config = config_manager.load()
            if hasattr(app_config, 'language') and app_config.language:
                set_language(app_config.language)
            else:
                # 默认使用中文
                set_language("zh-CN")
        except Exception:
            # 如果配置读取失败，使用默认语言
            set_language("zh-CN")
    
    def _load_theme_from_config(self) -> ThemeName:
        """从配置加载主题设置"""
        try:
            config_manager = ConfigManager()
            app_config = config_manager.load()
            if hasattr(app_config, 'theme') and app_config.theme:
                theme_name = app_config.theme
                # 验证主题名称是否有效
                if theme_name in ["light", "light_gray", "dark_gray", "claude_warm"]:
                    return theme_name
        except Exception:
            pass
        # 默认使用亮色主题
        return "light"
    
    def _build_top_toolbar(self):
        """构建顶部工具栏"""
        toolbar = ctk.CTkFrame(self, height=50, corner_radius=0)
        toolbar.grid(row=0, column=0, columnspan=2, sticky="ew")
        toolbar.grid_columnconfigure(1, weight=1)
        
        # 左侧：应用标题 + 当前模式
        title_frame = ctk.CTkFrame(toolbar, fg_color="transparent")
        title_frame.grid(row=0, column=0, padx=16, pady=8, sticky="w")
        
        self.title_label = ctk.CTkLabel(
            title_frame,
            text=f"{t('app_name')} – {self.current_mode}",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        self.title_label.pack(side="left", padx=8)
        
        # 中间：运行状态
        status_frame = ctk.CTkFrame(toolbar, fg_color="transparent")
        status_frame.grid(row=0, column=1, padx=16, pady=8, sticky="ew")
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text=f"{t('status')}：{self.running_status}",
            font=ctk.CTkFont(size=12)
        )
        self.status_label.pack(side="left", padx=8)
        
        # 右侧：功能按钮区域
        button_frame = ctk.CTkFrame(toolbar, fg_color="transparent")
        button_frame.grid(row=0, column=2, padx=16, pady=8, sticky="e")
        
        # UI 语言切换
        lang_values = [t("language_zh"), t("language_en")]
        self.lang_combo = ctk.CTkComboBox(
            button_frame,
            values=lang_values,
            width=100,
            command=self._on_language_changed
        )
        # 根据当前语言设置默认值
        current_lang = get_language()
        if current_lang == "zh-CN":
            self.lang_combo.set(t("language_zh"))
        else:
            self.lang_combo.set(t("language_en"))
        self.lang_combo.pack(side="left", padx=4)
        
        # 主题切换
        theme_values = [
            t("theme_light"),
            t("theme_light_gray"),
            t("theme_dark_gray"),
            t("theme_claude_warm")
        ]
        self.theme_combo = ctk.CTkComboBox(
            button_frame,
            values=theme_values,
            width=120,
            command=self._on_theme_changed
        )
        # 设置当前主题
        current_theme_display = t(f"theme_{self.current_theme}")
        self.theme_combo.set(current_theme_display)
        self.theme_combo.pack(side="left", padx=4)
        
        # 打开输出文件夹按钮
        self.open_output_btn = ctk.CTkButton(
            button_frame,
            text=t("open_output_folder"),
            width=120,
            command=self._on_open_output_folder
        )
        self.open_output_btn.pack(side="left", padx=4)
        
        # 打开配置文件夹按钮
        self.open_config_btn = ctk.CTkButton(
            button_frame,
            text=t("open_config_folder"),
            width=120,
            command=self._on_open_config_folder
        )
        self.open_config_btn.pack(side="left", padx=4)
    
    def _build_sidebar(self):
        """构建左侧侧边栏"""
        sidebar = ctk.CTkFrame(self, width=200, corner_radius=0)
        sidebar.grid(row=1, column=0, sticky="nsew")
        sidebar.grid_propagate(False)
        
        # 侧边栏内容
        sidebar_content = ctk.CTkScrollableFrame(sidebar)
        sidebar_content.pack(fill="both", expand=True, padx=8, pady=8)
        
        # 主流程分组
        task_label = ctk.CTkLabel(
            sidebar_content,
            text=t("sidebar_task"),
            font=ctk.CTkFont(size=12, weight="bold")
        )
        task_label.pack(pady=(8, 4), anchor="w")
        
        self.channel_mode_btn = ctk.CTkButton(
            sidebar_content,
            text=t("channel_mode"),
            command=lambda: self._switch_page("channel"),
            anchor="w",
            fg_color="transparent",
            text_color=("gray10", "gray90"),
            hover_color=("gray70", "gray30")
        )
        self.channel_mode_btn.pack(fill="x", pady=2)
        
        # URL 列表模式（P1，暂时占位）
        self.url_list_mode_btn = ctk.CTkButton(
            sidebar_content,
            text=t("url_list_mode"),
            command=lambda: self._switch_page("url_list"),
            anchor="w",
            fg_color="transparent",
            text_color=("gray10", "gray90"),
            hover_color=("gray70", "gray30"),
            state="disabled"  # P1 功能，暂时禁用
        )
        self.url_list_mode_btn.pack(fill="x", pady=2)
        
        # 运行设置分组
        settings_label = ctk.CTkLabel(
            sidebar_content,
            text=t("sidebar_settings"),
            font=ctk.CTkFont(size=12, weight="bold")
        )
        settings_label.pack(pady=(16, 4), anchor="w")
        
        self.run_params_btn = ctk.CTkButton(
            sidebar_content,
            text=t("run_params"),
            command=lambda: self._switch_page("run_params"),
            anchor="w",
            fg_color="transparent",
            text_color=("gray10", "gray90"),
            hover_color=("gray70", "gray30")
        )
        self.run_params_btn.pack(fill="x", pady=2)
        
        self.network_ai_btn = ctk.CTkButton(
            sidebar_content,
            text=t("network_ai"),
            command=lambda: self._switch_page("network_ai"),
            anchor="w",
            fg_color="transparent",
            text_color=("gray10", "gray90"),
            hover_color=("gray70", "gray30")
        )
        self.network_ai_btn.pack(fill="x", pady=2)
        
        # 外观 & 系统分组
        appearance_label = ctk.CTkLabel(
            sidebar_content,
            text=t("sidebar_appearance"),
            font=ctk.CTkFont(size=12, weight="bold")
        )
        appearance_label.pack(pady=(16, 4), anchor="w")
        
        self.appearance_lang_btn = ctk.CTkButton(
            sidebar_content,
            text=t("appearance_lang"),
            command=lambda: self._switch_page("appearance"),
            anchor="w",
            fg_color="transparent",
            text_color=("gray10", "gray90"),
            hover_color=("gray70", "gray30")
        )
        self.appearance_lang_btn.pack(fill="x", pady=2)
        
        self.system_tools_btn = ctk.CTkButton(
            sidebar_content,
            text=t("system_tools"),
            command=lambda: self._switch_page("system"),
            anchor="w",
            fg_color="transparent",
            text_color=("gray10", "gray90"),
            hover_color=("gray70", "gray30")
        )
        self.system_tools_btn.pack(fill="x", pady=2)
    
    def _build_main_content(self):
        """构建中间主内容区"""
        # 主内容区容器
        self.main_content = ctk.CTkFrame(self)
        self.main_content.grid(row=1, column=1, sticky="nsew", padx=8, pady=8)
        self.main_content.grid_columnconfigure(0, weight=1)
        self.main_content.grid_rowconfigure(0, weight=1)
        
        # 页面容器（用于切换不同页面）
        self.page_container = ctk.CTkFrame(self.main_content)
        self.page_container.pack(fill="both", expand=True)
        
        # 存储各个页面
        self.pages: dict[str, ctk.CTkFrame] = {}
    
    def _build_log_panel(self):
        """构建底部日志框"""
        log_frame = ctk.CTkFrame(self, height=200, corner_radius=0)
        log_frame.grid(row=2, column=0, columnspan=2, sticky="ew")
        log_frame.grid_propagate(False)
        log_frame.grid_columnconfigure(0, weight=1)
        log_frame.grid_rowconfigure(0, weight=1)
        
        # 日志标题栏
        log_header = ctk.CTkFrame(log_frame, height=30, corner_radius=0)
        log_header.grid(row=0, column=0, sticky="ew")
        log_header.grid_columnconfigure(0, weight=1)
        
        log_title = ctk.CTkLabel(
            log_header,
            text=t("log_output"),
            font=ctk.CTkFont(size=12, weight="bold")
        )
        log_title.pack(side="left", padx=8, pady=4)
        
        # 日志文本框（只读）
        self.log_text = ctk.CTkTextbox(
            log_frame,
            height=170,
            state="disabled",
            font=ctk.CTkFont(family="Consolas", size=11)
        )
        self.log_text.grid(row=1, column=0, sticky="nsew", padx=8, pady=(0, 8))
        
        # 初始日志消息
        self._append_log("INFO", t("gui_started"))
    
    def _build_channel_mode_page(self) -> ctk.CTkFrame:
        """构建频道模式页面（使用假数据）"""
        page = ctk.CTkFrame(self.page_container)
        page.grid_columnconfigure(0, weight=1)
        
        # 标题
        title = ctk.CTkLabel(
            page,
            text=t("channel_mode"),
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title.pack(pady=16)
        
        # 频道 URL 输入框
        url_frame = ctk.CTkFrame(page, fg_color="transparent")
        url_frame.pack(fill="x", padx=32, pady=8)
        
        url_label = ctk.CTkLabel(url_frame, text=t("channel_url_label"))
        url_label.pack(side="left", padx=8)
        
        self.channel_url_entry = ctk.CTkEntry(
            url_frame,
            placeholder_text=t("channel_url_placeholder"),
            width=500
        )
        self.channel_url_entry.pack(side="left", fill="x", expand=True, padx=8)
        
        # 按钮区域
        button_frame = ctk.CTkFrame(page, fg_color="transparent")
        button_frame.pack(fill="x", padx=32, pady=8)
        
        self.check_new_btn = ctk.CTkButton(
            button_frame,
            text=t("check_new_videos"),
            command=self._on_check_new_videos,
            width=150
        )
        self.check_new_btn.pack(side="left", padx=8)
        
        self.start_processing_btn = ctk.CTkButton(
            button_frame,
            text=t("start_processing"),
            command=self._on_start_processing,
            width=150
        )
        self.start_processing_btn.pack(side="left", padx=8)
        
        # 配置区域（暂时使用假数据）
        config_frame = ctk.CTkFrame(page)
        config_frame.pack(fill="x", padx=32, pady=16)
        
        config_label = ctk.CTkLabel(
            config_frame,
            text=t("config_options"),
            font=ctk.CTkFont(size=12, weight="bold")
        )
        config_label.pack(pady=8)
        
        # 占位文本
        placeholder = ctk.CTkLabel(
            config_frame,
            text=t("config_placeholder"),
            font=ctk.CTkFont(size=11),
            text_color=("gray50", "gray50")
        )
        placeholder.pack(pady=8)
        
        # 统计信息区域（暂时使用假数据）
        stats_frame = ctk.CTkFrame(page)
        stats_frame.pack(fill="x", padx=32, pady=16)
        
        stats_label = ctk.CTkLabel(
            stats_frame,
            text=t("stats_info"),
            font=ctk.CTkFont(size=12, weight="bold")
        )
        stats_label.pack(pady=8)
        
        self.stats_text = ctk.CTkLabel(
            stats_frame,
            text=t("stats_template", total=0, success=0, failed=0, status=t("status_idle")),
            font=ctk.CTkFont(size=11),
            justify="left"
        )
        self.stats_text.pack(pady=8)
        
        return page
    
    def _build_run_params_page(self) -> ctk.CTkFrame:
        """构建运行参数页面"""
        page = ctk.CTkFrame(self.page_container)
        page.grid_columnconfigure(0, weight=1)
        
        # 标题
        title = ctk.CTkLabel(
            page,
            text=t("run_params"),
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title.pack(pady=16)
        
        # 并发数量设置
        concurrency_frame = ctk.CTkFrame(page)
        concurrency_frame.pack(fill="x", padx=32, pady=16)
        
        concurrency_label = ctk.CTkLabel(
            concurrency_frame,
            text=t("concurrency_label"),
            font=ctk.CTkFont(size=12)
        )
        concurrency_label.pack(side="left", padx=8, pady=8)
        
        self.concurrency_entry = ctk.CTkEntry(
            concurrency_frame,
            width=100,
            placeholder_text="3"
        )
        self.concurrency_entry.pack(side="left", padx=8, pady=8)
        # 确保配置已加载
        if self.app_config:
            self.concurrency_entry.insert(0, str(self.app_config.concurrency))
        else:
            self.concurrency_entry.insert(0, "3")
        
        concurrency_hint = ctk.CTkLabel(
            concurrency_frame,
            text=t("concurrency_hint"),
            font=ctk.CTkFont(size=11),
            text_color=("gray50", "gray50")
        )
        concurrency_hint.pack(side="left", padx=8, pady=8)
        
        # 保存按钮
        button_frame = ctk.CTkFrame(page, fg_color="transparent")
        button_frame.pack(fill="x", padx=32, pady=16)
        
        save_btn = ctk.CTkButton(
            button_frame,
            text=t("save_settings"),
            command=self._on_save_run_params,
            width=120
        )
        save_btn.pack(side="left", padx=8)
        
        # 提示信息
        hint_label = ctk.CTkLabel(
            page,
            text=t("save_settings_hint"),
            font=ctk.CTkFont(size=11),
            text_color=("gray50", "gray50")
        )
        hint_label.pack(pady=8)
        
        return page
    
    def _on_save_run_params(self):
        """保存运行参数"""
        try:
            # 读取并发数
            concurrency_str = self.concurrency_entry.get().strip()
            if not concurrency_str:
                self._append_log("WARN", t("concurrency_empty"))
                return
            
            try:
                concurrency = int(concurrency_str)
                if concurrency <= 0:
                    self._append_log("WARN", t("concurrency_too_low"))
                    concurrency = 1
                    self.concurrency_entry.delete(0, "end")
                    self.concurrency_entry.insert(0, "1")
                
                # 更新配置（确保配置已初始化）
                if not self.app_config:
                    self._init_core_components()
                self.app_config.concurrency = concurrency
                self.config_manager.save(self.app_config)
                
                # 警告提示
                if concurrency > 10:
                    self._append_log("WARN", t("concurrency_high_warning", value=concurrency))
                elif concurrency > 5:
                    self._append_log("INFO", t("concurrency_medium_warning", value=concurrency))
                else:
                    self._append_log("INFO", t("concurrency_updated", value=concurrency))
                
            except ValueError:
                self._append_log("WARN", t("concurrency_invalid"))
                return
                
        except Exception as e:
            self._append_log("ERROR", t("save_params_failed", error=str(e)))
    
    def _switch_page(self, page_name: str):
        """切换页面"""
        # 清除当前页面
        for widget in self.page_container.winfo_children():
            widget.destroy()
        
        # 清空页面缓存（因为组件已被销毁）
        self.pages.clear()
        
        # 创建并显示目标页面
        if page_name == "channel":
            page = self._build_channel_mode_page()
            page.pack(fill="both", expand=True)
            self.current_mode = t("channel_mode")
            if hasattr(self, 'title_label'):
                self.title_label.configure(text=f"{t('app_name')} – {self.current_mode}")
        elif page_name == "run_params":
            # 确保配置已加载
            if not self.app_config:
                self._init_core_components()
            page = self._build_run_params_page()
            page.pack(fill="both", expand=True)
            self.current_mode = t("run_params")
            if hasattr(self, 'title_label'):
                self.title_label.configure(text=f"{t('app_name')} – {self.current_mode}")
        else:
            # 其他页面暂时显示占位文本
            placeholder = ctk.CTkLabel(
                self.page_container,
                text=t("page_not_implemented", page=page_name),
                font=ctk.CTkFont(size=14)
            )
            placeholder.pack(expand=True)
    
    def _init_core_components(self):
        """初始化核心组件"""
        logger = get_logger()
        
        try:
            # 重新加载配置（确保使用最新配置）
            self.app_config = self.config_manager.load()
            
            # 初始化代理管理器
            if self.app_config.proxies:
                self.proxy_manager = ProxyManager(self.app_config.proxies)
                logger.info(f"已加载 {len(self.app_config.proxies)} 个代理")
            else:
                self.proxy_manager = None
                logger.info("未配置代理，将使用直连")
            
            # 初始化 Cookie 管理器
            if self.app_config.cookie:
                self.cookie_manager = CookieManager(self.app_config.cookie)
                logger.info("已加载 Cookie")
            else:
                self.cookie_manager = None
            
            # 初始化 VideoFetcher
            self.video_fetcher = VideoFetcher(
                proxy_manager=self.proxy_manager,
                cookie_manager=self.cookie_manager
            )
            
            # 初始化 OutputWriter
            output_dir = Path(self.app_config.output_dir)
            self.output_writer = OutputWriter(output_dir)
            
            # 初始化 IncrementalManager
            self.incremental_manager = IncrementalManager()
            
            # 初始化 FailureLogger
            self.failure_logger = FailureLogger(output_dir)
            
            # 初始化 LLMClient（可能失败，允许为 None）
            try:
                self.llm_client = create_llm_client(self.app_config.ai)
                logger.info(f"AI 客户端已初始化：{self.app_config.ai.provider}/{self.app_config.ai.model}")
            except LLMException as e:
                logger.warning(f"AI 客户端初始化失败，将跳过翻译和摘要：{e}")
                self.llm_client = None
            
            self._append_log("INFO", "核心组件初始化完成")
        except Exception as e:
            logger.error(f"初始化核心组件失败：{e}")
            self._append_log("ERROR", t("core_components_init_failed", error=str(e)))
    
    def _on_check_new_videos(self):
        """检查新视频按钮点击（Dry Run）"""
        url = self.channel_url_entry.get().strip()
        if not url:
            self._append_log("WARN", "请输入频道 URL")
            return
        
        if self.is_processing:
            self._append_log("WARN", "正在处理中，请等待完成")
            return
        
        # 在后台线程中执行 Dry Run
        def dry_run_task():
            try:
                self.set_running_status(t("status_detecting"))
                self._append_log("INFO", t("dry_run_start", url=url))
                
                # 获取视频列表
                if not self.video_fetcher:
                    self._init_core_components()
                
                self.after(0, lambda: self._append_log("INFO", t("fetching_videos")))
                
                try:
                    videos = self.video_fetcher.fetch_from_url(url)
                except Exception as e:
                    import traceback
                    error_detail = t("fetch_videos_failed", error=str(e))
                    self.after(0, lambda: self._append_log("ERROR", error_detail))
                    self.after(0, lambda: self.set_running_status(t("status_idle")))
                    return
                
                if not videos:
                    error_msg = t("no_videos_found")
                    self.after(0, lambda: self._append_log("WARN", error_msg))
                    self.after(0, lambda: self.set_running_status(t("status_idle")))
                    return
                
                # 保存视频列表到文件
                channel_name = videos[0].channel_name if videos else None
                channel_id = videos[0].channel_id if videos else None
                self._save_video_list(videos, url, channel_name, channel_id)
                
                self.after(0, lambda: self._append_log("INFO", t("videos_found", count=len(videos))))
                
                # 检测字幕（Dry Run：只检测，不下载，不处理）
                detector = SubtitleDetector()
                has_subtitle_count = 0
                no_subtitle_count = 0
                
                for i, video in enumerate(videos, 1):
                    try:
                        result = detector.detect(video)
                        if result.has_subtitles:
                            has_subtitle_count += 1
                            
                            # 分别格式化手动字幕和自动字幕
                            manual_langs = ", ".join(result.manual_languages) if result.manual_languages else t("no_subtitles_short")
                            auto_langs = ", ".join(result.auto_languages) if result.auto_languages else t("no_subtitles_short")
                            
                            # 构建显示消息
                            subtitle_info_parts = []
                            if result.manual_languages:
                                subtitle_info_parts.append(f"{t('manual_subtitles')}：{manual_langs}")
                            if result.auto_languages:
                                subtitle_info_parts.append(f"{t('auto_subtitles')}：{auto_langs}")
                            
                            subtitle_info = " | ".join(subtitle_info_parts)
                            
                            self.after(0, lambda v=video, info=subtitle_info: self._append_log(
                                "INFO", 
                                t("subtitle_detected", video_id=v.video_id, title=v.title[:50], subtitle_info=info),
                                video_id=v.video_id
                            ))
                        else:
                            no_subtitle_count += 1
                            self.after(0, lambda v=video: self._append_log(
                                "WARN",
                                t("no_subtitle", video_id=v.video_id, title=v.title[:50]),
                                video_id=v.video_id
                            ))
                    except Exception as e:
                        self.after(0, lambda v=video, err=str(e): self._append_log(
                            "ERROR",
                            t("subtitle_detect_failed", video_id=v.video_id, error=err),
                            video_id=v.video_id
                        ))
                
                # 显示统计结果
                self.after(0, lambda: self._append_log("INFO", t("detection_complete", has_count=has_subtitle_count, no_count=no_subtitle_count)))
                self.after(0, lambda: self.set_running_status(t("status_idle")))
                
            except Exception as e:
                self.after(0, lambda: self._append_log("ERROR", f"Dry Run 失败：{e}"))
                self.after(0, lambda: self.set_running_status("空闲"))
        
        thread = threading.Thread(target=dry_run_task, daemon=True)
        thread.start()
    
    def _on_start_processing(self):
        """开始处理按钮点击"""
        url = self.channel_url_entry.get().strip()
        if not url:
            self._append_log("WARN", "请输入频道 URL")
            return
        
        if self.is_processing:
            self._append_log("WARN", "正在处理中，请等待完成")
            return
        
        # 在后台线程中执行处理
        def process_task():
            try:
                self.is_processing = True
                self.set_running_status("处理中...")
                self._append_log("INFO", f"开始处理：{url}")
                
                # 确保核心组件已初始化
                if not self.video_fetcher:
                    self._init_core_components()
                
                # 获取视频列表
                self.after(0, lambda: self._append_log("INFO", "正在获取视频列表（可能需要一些时间）..."))
                videos = self.video_fetcher.fetch_from_url(url)
                
                if not videos:
                    error_msg = (
                        "未获取到任何视频。可能的原因：\n"
                        "1. 频道 URL 不正确或格式错误\n"
                        "2. 需要 Cookie 才能访问（请在配置中添加 Cookie）\n"
                        "3. 网络连接问题或超时\n"
                        "4. yt-dlp 执行失败（请查看日志文件获取详细错误信息）\n"
                        "提示：请检查日志文件中的错误信息，或尝试在配置中添加 Cookie"
                    )
                    self.after(0, lambda: self._append_log("ERROR", error_msg))
                    self.is_processing = False
                    self.after(0, lambda: self.set_running_status("空闲"))
                    return
                
                # 保存视频列表到文件
                channel_name = videos[0].channel_name if videos else None
                channel_id = videos[0].channel_id if videos else None
                self._save_video_list(videos, url, channel_name, channel_id)
                
                # 获取 archive 路径（用于增量处理）
                channel_id = videos[0].channel_id if videos else None
                archive_path = self.incremental_manager.get_or_create_channel_archive(channel_id)
                
                # 检查是否强制重跑（暂时从 UI 读取，P0-25 会完善）
                force = False  # TODO: 从 UI 读取强制重跑选项
                
                # 更新统计信息
                self.stats["total"] = len(videos)
                self.stats["success"] = 0
                self.stats["failed"] = 0
                self.stats["current"] = 0
                self.after(0, self._update_stats_display)
                
                self.after(0, lambda: self._append_log("INFO", f"共 {len(videos)} 个视频，开始处理..."))
                
                # 调用核心流水线
                result = process_video_list(
                    videos=videos,
                    language_config=self.app_config.language,
                    llm=self.llm_client,
                    output_writer=self.output_writer,
                    failure_logger=self.failure_logger,
                    incremental_manager=self.incremental_manager,
                    archive_path=archive_path,
                    force=force,
                    concurrency=self.app_config.concurrency,
                    proxy_manager=self.proxy_manager,
                    cookie_manager=self.cookie_manager
                )
                
                # 更新统计信息
                self.stats["success"] = result.get("success", 0)
                self.stats["failed"] = result.get("failed", 0)
                self.stats["current"] = self.stats["total"]
                self.after(0, self._update_stats_display)
                
                # 显示完成消息
                self.after(0, lambda: self._append_log("INFO", 
                    f"处理完成：成功 {self.stats['success']} 个，失败 {self.stats['failed']} 个"))
                self.is_processing = False
                self.after(0, lambda: self.set_running_status("空闲"))
                
            except Exception as e:
                import traceback
                error_msg = f"处理失败：{e}\n{traceback.format_exc()}"
                self.after(0, lambda: self._append_log("ERROR", error_msg))
                self.is_processing = False
                self.after(0, lambda: self.set_running_status("空闲"))
        
        self.processing_thread = threading.Thread(target=process_task, daemon=True)
        self.processing_thread.start()
    
    def _update_stats_display(self):
        """更新统计信息显示"""
        if hasattr(self, 'stats_text'):
            stats_str = t("stats_template", 
                         total=self.stats['total'],
                         success=self.stats['success'],
                         failed=self.stats['failed'],
                         status=self.running_status)
            self.stats_text.configure(text=stats_str)
    
    def _on_language_changed(self, value: str):
        """语言切换回调"""
        # 根据显示文本确定语言代码
        if value == t("language_zh"):
            new_lang = "zh-CN"
        elif value == t("language_en"):
            new_lang = "en-US"
        else:
            return
        
        # 如果语言没有变化，不执行切换
        if get_language() == new_lang:
            return
        
        # 设置新语言
        set_language(new_lang)
        
        # 保存到配置（如果配置支持）
        try:
            if self.app_config and hasattr(self.app_config, 'language'):
                self.app_config.language = new_lang
                self.config_manager.save(self.app_config)
        except Exception:
            pass
        
        # 重新构建 UI（刷新所有文本）
        self._refresh_ui_texts()
        
        self._append_log("INFO", f"Language changed to {new_lang}")
    
    def _refresh_ui_texts(self):
        """刷新 UI 中的所有文本（语言切换后调用）"""
        # 更新窗口标题
        self.title(t("app_name"))
        
        # 更新顶部工具栏
        if hasattr(self, 'title_label'):
            self.title_label.configure(text=f"{t('app_name')} – {self.current_mode}")
        
        if hasattr(self, 'status_label'):
            self.status_label.configure(text=f"{t('status')}：{self.running_status}")
        
        # 更新语言下拉框（防止循环调用）
        if hasattr(self, 'lang_combo'):
            lang_values = [t("language_zh"), t("language_en")]
            current_lang = get_language()
            # 临时保存 command
            original_command = self.lang_combo.cget("command")
            # 临时禁用 command
            self.lang_combo.configure(command=None)
            # 更新值
            self.lang_combo.configure(values=lang_values)
            if current_lang == "zh-CN":
                self.lang_combo.set(t("language_zh"))
            else:
                self.lang_combo.set(t("language_en"))
            # 恢复 command
            self.lang_combo.configure(command=original_command)
        
        # 语言切换后，先重新应用当前主题，确保所有颜色和文本都正确更新
        # 然后再更新主题下拉框（避免主题下拉框更新时触发主题切换）
        try:
            # 确保主题 tokens 是最新的
            self.theme_tokens = get_theme(self.current_theme)
            # 立即应用主题（不使用延迟，确保立即生效）
            self._apply_theme_immediate()
        except Exception:
            pass
        
        # 更新主题下拉框（使用专门的方法，已包含防止循环调用的逻辑）
        # 注意：必须在主题应用之后更新，避免触发主题切换
        # 使用延迟执行，确保主题应用完成后再更新下拉框
        self.after(150, self._refresh_theme_combo)
        
        # 更新按钮文本
        if hasattr(self, 'open_output_btn'):
            self.open_output_btn.configure(text=t("open_output_folder"))
        if hasattr(self, 'open_config_btn'):
            self.open_config_btn.configure(text=t("open_config_folder"))
        
        # 更新侧边栏按钮
        if hasattr(self, 'channel_mode_btn'):
            self.channel_mode_btn.configure(text=t("channel_mode"))
        if hasattr(self, 'url_list_mode_btn'):
            self.url_list_mode_btn.configure(text=t("url_list_mode"))
        if hasattr(self, 'run_params_btn'):
            self.run_params_btn.configure(text=t("run_params"))
        if hasattr(self, 'network_ai_btn'):
            self.network_ai_btn.configure(text=t("network_ai"))
        if hasattr(self, 'appearance_lang_btn'):
            self.appearance_lang_btn.configure(text=t("appearance_lang"))
        if hasattr(self, 'system_tools_btn'):
            self.system_tools_btn.configure(text=t("system_tools"))
        
        # 重新构建当前页面（刷新页面内容）
        if hasattr(self, 'page_container'):
            current_page = None
            # 根据当前模式确定页面（使用原始模式字符串，不依赖翻译）
            if hasattr(self, 'current_mode'):
                # 尝试匹配当前模式
                if "channel" in self.current_mode.lower() or "频道" in self.current_mode:
                    current_page = "channel"
                elif "run_params" in self.current_mode.lower() or "运行参数" in self.current_mode or "参数" in self.current_mode:
                    current_page = "run_params"
            
            if current_page:
                self._switch_page(current_page)
    
    def _on_theme_changed(self, value: str):
        """主题切换回调（支持 i18n）"""
        # 防止循环调用：如果正在刷新主题下拉框，忽略此次调用
        if hasattr(self, '_refreshing_theme_combo') and self._refreshing_theme_combo:
            return
        
        # 根据显示文本确定主题名称（支持中英文）
        theme_map = {}
        for theme_key in ["light", "light_gray", "dark_gray", "claude_warm"]:
            theme_map[t(f"theme_{theme_key}")] = theme_key
        
        theme_name = theme_map.get(value, "light")
        
        if theme_name != self.current_theme:
            self.current_theme = theme_name
            self.theme_tokens = get_theme(theme_name)
            
            # 保存到配置
            try:
                if self.app_config and hasattr(self.app_config, 'theme'):
                    self.app_config.theme = theme_name
                    self.config_manager.save(self.app_config)
            except Exception:
                pass
            
            # 应用主题
            self._apply_theme()
            
            # 刷新主题下拉框（因为语言可能变化）
            self._refresh_theme_combo()
            
            self._append_log("INFO", f"Theme changed to {theme_name}")
    
    def _refresh_theme_combo(self):
        """刷新主题下拉框（语言切换后调用）"""
        if not hasattr(self, 'theme_combo'):
            return
        
        # 设置标志，防止循环调用
        self._refreshing_theme_combo = True
        
        try:
            # 保存当前选中的主题名称（内部名称，不是显示文本）
            saved_theme = self.current_theme
            
            # 临时保存 command
            original_command = self.theme_combo.cget("command")
            
            # 完全禁用 command（防止触发回调）
            self.theme_combo.configure(command=None)
            
            try:
                # 更新下拉框的值列表（翻译后的名称）
                theme_values = [
                    t("theme_light"),
                    t("theme_light_gray"),
                    t("theme_dark_gray"),
                    t("theme_claude_warm")
                ]
                self.theme_combo.configure(values=theme_values)
                
                # 获取当前主题的显示文本（翻译后的名称）
                current_theme_display = t(f"theme_{saved_theme}")
                
                # 直接设置值，不触发任何事件
                # 使用 after 延迟执行，确保 command 已被完全禁用
                def set_value_safely():
                    try:
                        if hasattr(self, 'theme_combo') and hasattr(self, '_refreshing_theme_combo'):
                            # 再次确保 command 被禁用
                            self.theme_combo.configure(command=None)
                            # 设置值
                            self.theme_combo.set(current_theme_display)
                            # 恢复 command
                            self.theme_combo.configure(command=original_command)
                    except Exception:
                        # 如果出错，也要恢复 command
                        try:
                            if hasattr(self, 'theme_combo'):
                                self.theme_combo.configure(command=original_command)
                        except Exception:
                            pass
                    finally:
                        # 清除标志
                        if hasattr(self, '_refreshing_theme_combo'):
                            self._refreshing_theme_combo = False
                
                # 延迟执行，确保所有配置都已完成
                self.after(100, set_value_safely)
                
            except Exception:
                # 如果出错，恢复 command
                try:
                    self.theme_combo.configure(command=original_command)
                except Exception:
                    pass
                finally:
                    self._refreshing_theme_combo = False
        except Exception:
            self._refreshing_theme_combo = False
    
    def _apply_theme(self):
        """应用主题到所有 UI 组件"""
        tokens = self.theme_tokens
        
        # 设置 customtkinter 的外观模式（亮色/暗色）
        ctk_theme_map = {
            "light": "light",
            "light_gray": "light",
            "dark_gray": "dark",
            "claude_warm": "light",
        }
        ctk.set_appearance_mode(ctk_theme_map.get(self.current_theme, "light"))
        
        # 设置 customtkinter 的默认颜色主题
        ctk.set_default_color_theme("blue")
        
        # 强制更新所有组件的颜色（包括 dark_gray，确保颜色完全切换）
        # 使用 after 延迟执行，确保 appearance_mode 切换完成后再应用颜色
        self.after(10, lambda: self._apply_custom_colors(tokens))
    
    def _apply_theme_immediate(self):
        """立即应用主题到所有 UI 组件（不使用延迟，用于语言切换后）"""
        tokens = self.theme_tokens
        
        # 设置 customtkinter 的外观模式（亮色/暗色）
        ctk_theme_map = {
            "light": "light",
            "light_gray": "light",
            "dark_gray": "dark",
            "claude_warm": "light",
        }
        ctk.set_appearance_mode(ctk_theme_map.get(self.current_theme, "light"))
        
        # 设置 customtkinter 的默认颜色主题
        ctk.set_default_color_theme("blue")
        
        # 立即应用颜色（不使用延迟）
        self._apply_custom_colors(tokens)
    
    def _apply_custom_colors(self, tokens: ThemeTokens):
        """应用自定义颜色到所有组件（所有主题都需要，确保颜色完全切换）"""
        try:
            # 先更新主窗口背景
            try:
                # customtkinter 的主窗口背景通过 fg_color 设置（使用元组形式确保完全切换）
                self.configure(fg_color=(tokens.bg_primary, tokens.bg_primary))
            except Exception:
                pass
            
            # 更新主要区域的背景色（确保图层正确）
            if hasattr(self, 'main_content'):
                try:
                    self.main_content.configure(fg_color=(tokens.bg_primary, tokens.bg_primary))
                except Exception:
                    pass
            
            # 递归应用颜色到所有组件
            self._apply_colors_to_widgets(self, tokens)
            
            # 强制刷新显示
            self.update_idletasks()
        except Exception as e:
            # 忽略错误，继续运行
            pass
    
    def _apply_colors_to_widgets(self, parent, tokens: ThemeTokens):
        """递归应用颜色到所有子组件，确保完全清除旧颜色"""
        try:
            for widget in parent.winfo_children():
                # 根据组件类型应用不同的颜色
                if isinstance(widget, ctk.CTkFrame):
                    # 框架：使用背景色
                    try:
                        current_color = widget.cget("fg_color")
                        # 跳过透明框架
                        if current_color == "transparent" or current_color == ("transparent", "transparent"):
                            # 递归处理子组件，但不改变透明框架本身
                            self._apply_colors_to_widgets(widget, tokens)
                            continue
                        
                        # 强制更新框架背景色（使用元组形式确保完全切换）
                        widget.configure(fg_color=(tokens.bg_secondary, tokens.bg_secondary))
                    except Exception:
                        pass
                
                elif isinstance(widget, ctk.CTkLabel):
                    # 标签：使用文本色
                    try:
                        widget.configure(text_color=(tokens.text_primary, tokens.text_primary))
                    except Exception:
                        pass
                
                elif isinstance(widget, ctk.CTkButton):
                    # 按钮：使用强调色
                    try:
                        widget.configure(
                            fg_color=(tokens.accent, tokens.accent),
                            hover_color=(tokens.accent_hover, tokens.accent_hover),
                            text_color=(tokens.text_primary, tokens.text_primary)
                        )
                    except Exception:
                        pass
                
                elif isinstance(widget, ctk.CTkEntry):
                    # 输入框：使用第三级背景色
                    try:
                        widget.configure(
                            fg_color=(tokens.bg_tertiary, tokens.bg_tertiary),
                            text_color=(tokens.text_primary, tokens.text_primary),
                            border_color=(tokens.border, tokens.border)
                        )
                    except Exception:
                        pass
                
                elif isinstance(widget, ctk.CTkTextbox):
                    # 文本框：使用第三级背景色
                    try:
                        widget.configure(
                            fg_color=(tokens.bg_tertiary, tokens.bg_tertiary),
                            text_color=(tokens.text_primary, tokens.text_primary)
                        )
                    except Exception:
                        pass
                
                elif isinstance(widget, ctk.CTkComboBox):
                    # 下拉框：使用第三级背景色
                    try:
                        widget.configure(
                            fg_color=(tokens.bg_tertiary, tokens.bg_tertiary),
                            text_color=(tokens.text_primary, tokens.text_primary),
                            button_color=(tokens.accent, tokens.accent),
                            button_hover_color=(tokens.accent_hover, tokens.accent_hover)
                        )
                    except Exception:
                        pass
                
                elif isinstance(widget, ctk.CTkScrollableFrame):
                    # 可滚动框架：使用背景色
                    try:
                        widget.configure(fg_color=(tokens.bg_secondary, tokens.bg_secondary))
                    except Exception:
                        pass
                
                # 递归处理子组件
                self._apply_colors_to_widgets(widget, tokens)
                
        except Exception:
            # 忽略错误，继续处理其他组件
            pass
    
    def _on_open_output_folder(self):
        """打开输出文件夹"""
        output_dir = Path(self.app_config.output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        import subprocess
        import platform
        
        system = platform.system()
        if system == "Windows":
            subprocess.Popen(f'explorer "{output_dir.absolute()}"')
        elif system == "Darwin":  # macOS
            subprocess.Popen(["open", str(output_dir.absolute())])
        else:  # Linux
            subprocess.Popen(["xdg-open", str(output_dir.absolute())])
        
        self._append_log("INFO", f"已打开输出文件夹：{output_dir.absolute()}")
    
    def _on_open_config_folder(self):
        """打开配置文件夹"""
        config_dir = get_user_data_dir()
        import subprocess
        import platform
        
        system = platform.system()
        if system == "Windows":
            subprocess.Popen(f'explorer "{config_dir.absolute()}"')
        elif system == "Darwin":  # macOS
            subprocess.Popen(["open", str(config_dir.absolute())])
        else:  # Linux
            subprocess.Popen(["xdg-open", str(config_dir.absolute())])
        
        self._append_log("INFO", f"已打开配置文件夹：{config_dir.absolute()}")
    
    def _on_log_message(self, level: str, message: str, video_id: Optional[str] = None):
        """日志回调函数（从 Logger 接收日志）"""
        # 在主线程中更新 UI
        self.after(0, lambda: self._append_log(level, message, video_id))
    
    def _append_log(self, level: str, message: str, video_id: Optional[str] = None):
        """追加日志到日志框"""
        self.log_text.configure(state="normal")
        
        # 格式化日志消息
        if video_id:
            log_line = f"[{level}] [{video_id}] {message}\n"
        else:
            log_line = f"[{level}] {message}\n"
        
        self.log_text.insert("end", log_line)
        self.log_text.see("end")  # 自动滚动到底部
        self.log_text.configure(state="disabled")
    
    def set_running_status(self, status: str):
        """设置运行状态"""
        self.running_status = status
        self.status_label.configure(text=f"{t('status')}：{status}")
    
    def _save_video_list(self, videos: list, source_url: str, channel_name: Optional[str] = None, channel_id: Optional[str] = None):
        """保存视频列表到文件（追加模式）
        
        Args:
            videos: 视频列表
            source_url: 来源 URL（频道/播放列表 URL）
            channel_name: 频道名称（如果有）
            channel_id: 频道 ID（如果有）
        """
        try:
            # 保存到输出目录
            output_dir = Path(self.app_config.output_dir)
            output_dir.mkdir(parents=True, exist_ok=True)
            video_list_file = output_dir / "video_list.txt"
            
            # 构建分隔符
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            separator_parts = [f"# {timestamp}"]
            
            if channel_name and channel_id:
                separator_parts.append(f"频道: {channel_name} [{channel_id}]")
            elif channel_id:
                separator_parts.append(f"频道 ID: {channel_id}")
            else:
                separator_parts.append(f"来源: {source_url}")
            
            separator_parts.append(f"视频数量: {len(videos)}")
            separator = " | ".join(separator_parts)
            
            # 追加模式写入
            with open(video_list_file, "a", encoding="utf-8") as f:
                f.write("\n")
                f.write(separator + "\n")
                for video in videos:
                    f.write(video.url + "\n")
                f.write("# " + "=" * 60 + "\n")  # 结束分隔符
            
            logger = get_logger()
            logger.info(f"已保存 {len(videos)} 个视频链接到: {video_list_file}")
            self.after(0, lambda: self._append_log("INFO", f"已保存 {len(videos)} 个视频链接到: {video_list_file.name}"))
            
        except Exception as e:
            logger = get_logger()
            logger.error(f"保存视频列表失败: {e}")
            self.after(0, lambda: self._append_log("WARN", f"保存视频列表失败: {e}"))
